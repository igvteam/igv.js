<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="Jim Robinson" name="author">
    <link href=img/favicon.ico rel="shortcut icon">
    <title>igv.js</title>
    <style>.filters li { display: inline} </style>
    <script>

    /** Render update to reflect newly-selected features in IGV track */
    function updateTrack(trackIndex, filteredFeatures, igv, igvBrowser) {
      igv.FeatureUtils.packFeatures(filteredFeatures)
      const range = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.range
      igvBrowser.trackViews[trackIndex].track.featureSource.featureCache =
        new igv.FeatureCache(filteredFeatures, igvBrowser.genome, range)

      igvBrowser.trackViews[trackIndex].track.clearCachedFeatures()
      igvBrowser.trackViews[trackIndex].track.updateViews()
    }

    /** Get unfiltered genomic features on current chromosome */
    function getOriginalChrFeatures(trackIndex, igvBrowser) {
      const chr = Array.from(igvBrowser.tracks[0].trackView.viewports[0].featureCache.features.keys())[0]

      console.log('igvBrowser.tracks[0]', igvBrowser.tracks[0])
      console.log('chr', chr)

      if (
        typeof window.originalFeatures === 'undefined' ||
        chr in window.originalFeatures === false
      ) {
        window.originalFeatures = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.allFeatures
      }

      const originalChrFeatures = window.originalFeatures[chr]

      return originalChrFeatures
    }

    /** Determine if feature is in genomic frame */
    function getIsFeatureInFrame(feature, igvBrowser) {
      const frame = igvBrowser.referenceFrameList[0]

      const isFeatureInFrame = (
        // Contained:
        // Frame:     --------
        // Feature:     ----
        (feature.start >= frame.start && feature.end <= frame.end) ||

        // Overlaps start
        // Frame:     --------
        // Feature:  ----
        (feature.start <= frame.start && feature.end >= frame.start) ||

        // Overlaps end
        // Frame:     --------
        // Feature:         ----
        (feature.start <= frame.end && feature.end >= frame.end) ||

        // Spans
        // Frame:     --------
        // Feature: ------------
        (feature.start <= frame.start && feature.end >= frame.end)
      )

      return isFeatureInFrame
    }

    function filterFeatures(trackSelector, dimension) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);

      const selection = new Set([])

      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)

      const facetSel = `.igv-facet-${dimension}`
      const inputs = document.querySelectorAll(`.filters ${facetSel} input`)
      console.log('in filterFeatures, inputs', inputs)
      inputs.forEach(input => {
        if (input.checked) {
          selection.add(input.value)
        }
      })

      if (selection.size === 0) {
        return selection.originalChrFeatures
      }

      const filteredFeatures = originalChrFeatures.filter(
        feature => selection.has(feature.info[dimension]) && getIsFeatureInFrame(feature, igvBrowser)
      )

      console.log('filteredFeatures', filteredFeatures)
      updateTrack(trackIndex, filteredFeatures, igv, igvBrowser)
    }

    function getFeaturesInFrame(trackSelector, igvBrowser) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);
      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)
      const featuresInFrame = originalChrFeatures.filter(
        feature => getIsFeatureInFrame(feature, igvBrowser)
      )
      return featuresInFrame
    }

    /** Get index position of track in IGV browser, given its name or index */
    function getTrackIndex(trackSelector, igvBrowser) {
      let trackIndex = null
      if (typeof trackSelector === 'string') {
        igvBrowser.trackViews.find((trackView, i) => {
          trackIndex = i
          return trackView.track.config?.name === trackSelector
        })
      } else {
        trackIndex = trackSelector
      }
      return trackIndex
    }

    function getStatistics(numbers) {
      // Sort the array in ascending order
      numbers.sort((a, b) => a - b);

      // Compute the sum using a loop for faster mean calculation
      let sum = 0;
      for (let i = 0; i < numbers.length; i++) {
          sum += numbers[i];
      }
      const mean = sum / numbers.length;

      const max = numbers[numbers.length - 1];
      const min = numbers[0];
      const median = getMedian(numbers);

      // Divide the array into two halves
      const midIndex = Math.floor(numbers.length / 2);
      const lowerHalf = numbers.slice(0, midIndex);
      const upperHalf = numbers.length % 2 === 0
          ? numbers.slice(midIndex)
          : numbers.slice(midIndex + 1);

      const q1 = getMedian(lowerHalf);
      const q3 = getMedian(upperHalf);

      return { min, q1, median, q3, max, mean };
    }

    function getMedian(numbers) {
      const midIndex = Math.floor(numbers.length / 2);

      // If the array has an odd length, return the middle number
      if (numbers.length % 2 !== 0) {
        return numbers[midIndex];
      }

      // If the array has an even length, return the average of the two middle numbers
      return (numbers[midIndex - 1] + numbers[midIndex]) / 2;
    }

    /**
     * Initialize facets and filters for the current genomic frame
     *
     * Output:
     * {
     *   "features": [
     *      // Each "feature" (e.g. variant, read, gene) is represented as an
     *      // array of numbers.  For categorical facets, each number is a
     *      // compact representation (e.g. 0) of the filter / value (e.g.
     *      // "SNP") of a particular facet / dimension (e.g. "VT").
     *      [<Number>]
     *    ],
     *   "facets": [
     *     {
     *       "name": <String>, // Internal name of facet, e.g. "VT"
     *
     *       "displayName": <String>, // e.g. "Variant type"
     *
     *       "type": <String> // "categorical" or "integer" or "float"
     *
     *       // For categorical: names of filters in facet
     *       // The index of these names correspond to the integer value at the
     *       // appropriate position in the `features` array.
     *       "filterNames": [<String>],
     *
     *       // For categorical: number of features satisfying each filter
     *       "countsByFilterName": {
     *          <String>: <Integer>
     *       }
     *
     *      // For integer or float: numeric values observed for this facet
     *      "filterNumbers": [<Number>],
     *
     *      "statistics": {
     *        "min": <Number>,
     *        "q1": <Number>,
     *        "median": <Number>,
     *        "q3": <Number>,
     *        "max": <Number>
     *      }
     *     }
     *   ]
     * }
     */
    function initFacets(trackSelector, igvBrowser) {
      const t0 = Date.now()
      const trackIndex = getTrackIndex(trackSelector, igvBrowser)
      const featuresInFrame = getFeaturesInFrame(trackIndex, igvBrowser)

      // Populate facets model, except for filterNames array values
      let facets = []
      const headInfo = featuresInFrame[0].header.INFO
      console.log('headInfo', headInfo)
      const dimensions = Object.keys(headInfo);
      dimensions.forEach(dimension => {
        const igvFacet = headInfo[dimension]
        // string, flag, integer, or float
        const igvType = igvFacet.Type.toLowerCase()
        const type = ['string', 'flag'].includes(igvType) ? 'categorical' : igvType
        const description = igvFacet.Description
        const facet = {'name': dimension, type, description}
        if (type === 'categorical') {
          facet.filterNames = []
          facet.countsByFilterName = {}
        } else {
          facet.filterNumbers = []
          facet.statistics = {}
        }
        facets.push(facet)
      })

      // Populate features, and (for each facet) filterNames
      const features = []
      for (let i = 0; i < featuresInFrame.length; i++) {
        const feature = []
        const igvFeature = featuresInFrame[i]
        const info = igvFeature.info
        let j = 0
        for (facetName in headInfo) {
          let value
          if (facetName in info === false) {
            // Use an "empty" value if the feature lacks a value
            // for this dimension, which is pretty common.
            value = undefined
          } else {
            const rawValue = info[facetName]
            const facet = facets[j]
            if (facet.type === 'categorical') {
              if (!facet.filterNames.includes(rawValue)) {
                // Populate filterNames
                facet.filterNames.push(rawValue);
                facet.countsByFilterName[rawValue] = 0
              }

              // Using index offsets as values, rather than raw strings, helps
              // make categorical filtering fast.
              value = facet.filterNames.indexOf(rawValue)
              facet.countsByFilterName[rawValue] += 1
            } else {
              const isFloat = facet.type === 'float'
              value = isFloat ? parseFloat(rawValue) : parseInt(rawValue)
              facet.filterNumbers.push(value)
            }
            facets[j] = facet
          }
          feature.push(value)
          j++
        }

        // Populate features
        features.push(feature)
      }

      // Populate statistics for numeric facets
      facets = facets.map(facet => {
        if (facet.type === 'categorical') return facet

        const {min, q1, median, q3, max, mean} = getStatistics(facet.filterNumbers)
        facet.statistics = {min, q1, median, q3, max, mean}

        return facet
      })

      const t1 = Date.now()
      console.log('initFacets duration (ms):', (t1 - t0))
      return {facets, features}
    }

    function getCategoricalFacetHtml(facet, isPartlyCollapsed=true) {
      // Categorical facets need > 1 filter to be useful
      const numFilters = facet.filterNames.length
      if (numFilters < 2) return ''

      let filters = facet.filterNames;
      if (isPartlyCollapsed) filters = filters.slice(0, 5)

      // Get list of filter checkboxes
      const filtersHtml = filters.map(filterName => {
        const fullName = `${facet.name}:${filterName}`
        const attrs = `
          value="${filterName}"
          name="${fullName}"
          onChange="filterFeatures('Phase 3 WGS variants', '${facet.name}')"
        `
        const count = facet.countsByFilterName[filterName]
        const filterHtml = `
          <label class="igv-filter-label">
            <div>
              <input type="checkbox" ${attrs} checked />
              <span class="igv-filter-label-text">${filterName}</span>
              <span class="igv-filter-label-quantities">
                <span class="igv-filter-count">${count}</span>
              </span>
            </div>
          </label>`
        return filterHtml
      }).join('')


      let moreOrLess = ''
      if (numFilters > 5) {
        moreOrLess = `
          <a
            className="igv-facet-toggle"
            onClick=""
          >
            ${isPartlyCollapsed ? 'More...' : 'Less...'}
          </a>`
        }

      const facetSel = `igv-facet-${facet.name}`
      // Add a facet header to the filters
      const facetHtml = `
        <div class="igv-facet ${facetSel}" style="width: 250px; float: left;">
          <span class="igv-facet-header">${facet.name}</span>
          ${filtersHtml}
          ${moreOrLess}
        </div>`

      // console.log('facetHtml', facetHtml)
      return facetHtml
    }

    function getNumericFacetHtml(facetContainer) {

    }

    function getFacetsHtml(trackSelector, browser) {
      const facetContainers = initFacets(trackSelector, browser)
      // console.log('facetContainers', facetContainers)
      const facetList = facetContainers.facets.map(facetContainer => {
        let facetHtml
        if (facetContainer.type === 'categorical') {
          facetHtml = getCategoricalFacetHtml(facetContainer)
        } else {
          facetHtml = '' // TODO: Support numeric facets
        }
        return facetHtml
      }).join('')

      const facetsHtml = `<div>${facetList}</div>`
      return facetsHtml
    }

  </script>
</head>

<body>

<h1>Ad-hoc filtering in IGV</h1>

<!-- <ul class="filters">
  <span>Type</span>
  <li><label>SNP <input type="checkbox" value="SNP" onChange="filterFeatures('Phase 3 WGS variants', 'type')" checked/></label></li>
  <li><label>INDEL <input type="checkbox" value="INDEL" onChange="filterFeatures('Phase 3 WGS variants', 'type')" checked/></label></li>
</ul> -->

<ul class="filters" style="float: left;">
</ul>


<div id="igvDiv" style="padding-top: 10px;padding-bottom: 10px; border:1px solid lightgray; clear: both;"></div>

<script type="module">

    import igv from "../js/index.js"

    const options =
        {
            // Example of fully specifying a reference .  We could alternatively use  "genome: 'hg19'"
            reference: {
                "id": "hg19",
                "name": "Human (CRCh37/hg19)",
                "fastaURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta",
                "indexURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta.fai",
                "cytobandURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/cytoBand.txt"
            },
            locus: "19:11,199,138-11,245,496",
            tracks:
                [
                    {
                        name: "Phase 3 WGS variants",
                        type: "variant",
                        format: "vcf",
                        visibilityWindow: 3000000,
                        url: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz",
                        indexURL: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz.tbi"
                    },
                    {
                        name: "Genes",
                        type: "annotation",
                        format: "bed",
                        url: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz",
                        indexURL: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz.tbi",
                        order: Number.MAX_VALUE,
                        visibilityWindow: 300000000,
                        displayMode: "EXPANDED"
                    }
                ]

        }

    var igvDiv = document.getElementById("igvDiv")

    window.igv = igv

    const browser = await igv.createBrowser(igvDiv, options)
    window.igvBrowser = browser

    browser.on('locuschange', referenceFrameList => {
      const facetsHtml = getFacetsHtml('Phase 3 WGS variants', browser)
      const filtersDom = document.querySelector('.filters')
      filtersDom.innerHTML = ''
      filtersDom.insertAdjacentHTML('beforeend', facetsHtml)
    })

</script>

</body>

</html>
