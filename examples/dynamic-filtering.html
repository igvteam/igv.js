<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="Jim Robinson" name="author">
    <link href=img/favicon.ico rel="shortcut icon">
    <title>igv.js</title>
    <style>.filters li { display: inline} </style>
    <script>

    /** Render update to reflect newly-selected features in IGV track */
    function updateTrack(trackIndex, filteredFeatures, igv, igvBrowser) {
      igv.FeatureUtils.packFeatures(filteredFeatures)
      const range = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.range
      igvBrowser.trackViews[trackIndex].track.featureSource.featureCache =
        new igv.FeatureCache(filteredFeatures, igvBrowser.genome, range)

      igvBrowser.trackViews[trackIndex].track.clearCachedFeatures()
      igvBrowser.trackViews[trackIndex].track.updateViews()
    }

    /** Get unfiltered genomic features on current chromosome */
    function getOriginalChrFeatures(trackIndex, igvBrowser) {
      const chr = Array.from(igvBrowser.tracks[0].trackView.viewports[0].featureCache.features.keys())[0]

      console.log('igvBrowser.tracks[0]', igvBrowser.tracks[0])
      console.log('igvBrowser.tracks[0]', igvBrowser.tracks[0])
      console.log('chr', chr)

      if (
        typeof window.originalFeatures === 'undefined' ||
        chr in window.originalFeatures === false
      ) {
        window.originalFeatures = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.allFeatures
      }

      const originalChrFeatures = window.originalFeatures[chr]

      return originalChrFeatures
    }

    /** Determine if feature is in genomic frame */
    function getIsFeatureInFrame(feature, igvBrowser) {
      const frame = igvBrowser.referenceFrameList[0]

      const isFeatureInFrame = (
        // Contained:
        // Frame:     --------
        // Feature:     ----
        (feature.start >= frame.start && feature.end <= frame.end) ||

        // Overlaps start
        // Frame:     --------
        // Feature:  ----
        (feature.start <= frame.start && feature.end >= frame.start) ||

        // Overlaps end
        // Frame:     --------
        // Feature:         ----
        (feature.start <= frame.end && feature.end >= frame.end) ||

        // Spans
        // Frame:     --------
        // Feature: ------------
        (feature.start <= frame.start && feature.end >= frame.end)
      )

      return isFeatureInFrame
    }

    function filterFeatures(trackSelector, dimension, igvBrowser) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);

      const scoreSelection = new Set([])

      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)

      const inputs = document.querySelectorAll('.filters input')
      inputs.forEach(input => {
        if (input.checked) {
          scoreSelection.add(input.value)
        }
      })

      if (scoreSelection.size === 0) {
        return scoreSelection.originalChrFeatures
      }

      const filteredFeatures = originalChrFeatures.filter(
        feature => scoreSelection.has(feature[dimension]) && getIsFeatureInFrame(feature, igvBrowser)
      )

      console.log('filteredFeatures', filteredFeatures)
      updateTrack(trackIndex, filteredFeatures, igv, igvBrowser)
    }

    function getFeaturesInFrame(trackSelector, igvBrowser) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);
      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)
      const featuresInFrame = originalChrFeatures.filter(
        feature => getIsFeatureInFrame(feature, igvBrowser)
      )
      return featuresInFrame
    }

    /** Get index position of track in IGV browser, given its name or index */
    function getTrackIndex(trackSelector, igvBrowser) {
      let trackIndex = null
      if (typeof trackSelector === 'string') {
        igvBrowser.trackViews.find((trackView, i) => {
          trackIndex = i
          return trackView.track.config?.name === trackSelector
        })
      } else {
        trackIndex = trackSelector
      }
      return trackIndex
    }

    /**
     * Initialize facets and filters for the current genomic frame
     *
     * Output:
     * {
     *   "features": [
     *      // Each "feature" (e.g. variant, read, gene) is represented as an
     *      // array of numbers.  For categorical facets, each number is a
     *      // compact representation (e.g. 0) of the filter / value (e.g.
     *      // "SNP") of a particular facet / dimension (e.g. "VT").
     *      [<Number>]
     *    ],
     *   "facets": [
     *     {
     *       "name": <String>, // Internal name of facet, e.g. "VT"
     *
     *       "displayName": <String>, // e.g. "Variant type"
     *
     *       "type": <String> // "categorical" or "numeric"
     *
     *       // Names of filters in facet, only for categorical facets.
     *       // The index of these names correspond to the integer value at the
     *       // appropriate position in the `features` array.
     *       "filterNames": [<String>],
     *
     *       // Number of features satisfying this filter (for categorical)
     *       "countsByFilterName": {
     *          <String>: <Integer>
     *       }
     *     }
     *   ]
     * }
     */
    function initFacets(trackSelector, igvBrowser) {
      const t0 = Date.now()
      const trackIndex = getTrackIndex(trackSelector, igvBrowser)
      const featuresInFrame = getFeaturesInFrame(trackIndex, igvBrowser)

      isCategoricalByFacetName = {}

      // Populate facets model, except for filterNames array values
      const facets = []
      const headInfo = featuresInFrame[0].header.INFO
      console.log('headInfo', headInfo)
      const dimensions = Object.keys(headInfo);
      dimensions.forEach(dimension => {
        const igvFacet = headInfo[dimension]
        // string, flag, integer, or float
        const igvType = igvFacet.Type.toLowerCase()
        const type = ['string', 'flag'].includes(igvType) ? 'categorical' : igvType
        const description = igvFacet.Description
        const facet = {'name': dimension, type, description}
        if (type === 'categorical') {
          facet.filterNames = []
          facet.countsByFilterName = {}
          isCategoricalByFacetName[facet.name] = true
        } else {
          isCategoricalByFacetName[facet.name] = false
        }
        facets.push(facet)
      })

      // Populate features, and (for each facet) filterNames
      const features = []
      for (let i = 0; i < featuresInFrame.length; i++) {
        const feature = []
        const igvFeature = featuresInFrame[i]
        const info = igvFeature.info
        let j = 0
        for (facetName in headInfo) {
          let value
          const isCategorical = isCategoricalByFacetName[facetName]
          if (facetName in info === false) {
            // Use an "empty" value if the feature lacks a value
            // for this dimension, which is pretty common.
            value = undefined
          } else {
            const rawValue = info[facetName]
            if (isCategorical) {
              if (!facets[j].filterNames.includes(rawValue)) {
                // Populate filterNames
                facets[j].filterNames.push(rawValue);
                facets[j].countsByFilterName[rawValue] = 0
              }

              // Using index offsets as values, rather than raw strings, helps
              // make categorical filtering fast.
              value = facets[j].filterNames.indexOf(rawValue)
              facets[j].countsByFilterName[rawValue] += 1
            } else {
              const isFloat = facets[j].type === 'float'
              value = isFloat ? parseFloat(rawValue) : parseInt(rawValue)
            }
          }
          feature.push(value)
          j++
        }

        // Populate features
        features.push(feature)
      }

      const t1 = Date.now()
      console.log('initFacets duration (ms):', (t1 - t0))
      return {facets, features}
    }

    function getCategoricalFacetHtml(facet) {
      const filtersHtml = facet.filterNames.map(filterName => {
        const fullName = `${facet.name}:${filterName}`
        const attrs = `value="${filterName}" name="${fullName}"`
        const count = facet.countsByFilterName[filterName]
        const filterHtml = `
          <label class="igv-filter-label">
            <div>
              <input type="checkbox" ${attrs} />
              <span class="igv-filter-label-text">${filterName}</span>
              <span class="igv-filter-label-quantities">
                <span class="igv-filter-count">${count}</span>
              </span>
            </div>
          </label>`
        console.log('filterHtml', filterHtml)
        return filterHtml
      }).join('')
      const facetHtml = `
        <div class="igv-facet">
          <span class="igv-facet-header">${facet.name}</span>
          ${filtersHtml}
        </div>`
      console.log('facetHtml', facetHtml)
      return facetHtml
    }

    function getFacetsHtml(trackSelector, browser) {
      let facetsHtml = ''
      const facetContainers = initFacets(trackSelector, browser)
      console.log('facetContainers', facetContainers)
      facetContainers.facets.forEach(facetContainer => {
        let facetHtml
        if (facetContainer.type === 'categorical') {
          facetHtml = getCategoricalFacetHtml(facetContainer)
        } else {
          facetHtml = '' // TODO: Support numeric facets
        }
        facetsHtml += facetHtml
      })
      return facetsHtml
    }

  </script>
</head>

<body>

<h1>Ad-hoc filtering in IGV</h1>

<!-- <ul class="filters">
  <span>Type</span>
  <li><label>SNP <input type="checkbox" value="SNP" onChange="filterFeatures('Phase 3 WGS variants', 'type')" checked/></label></li>
  <li><label>INDEL <input type="checkbox" value="INDEL" onChange="filterFeatures('Phase 3 WGS variants', 'type')" checked/></label></li>
</ul> -->

<ul class="filters">
</ul>


<div id="igvDiv" style="padding-top: 10px;padding-bottom: 10px; border:1px solid lightgray"></div>

<script type="module">

    import igv from "../js/index.js"

    const options =
        {
            // Example of fully specifying a reference .  We could alternatively use  "genome: 'hg19'"
            reference: {
                "id": "hg19",
                "name": "Human (CRCh37/hg19)",
                "fastaURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta",
                "indexURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta.fai",
                "cytobandURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/cytoBand.txt"
            },
            locus: "19:11,199,138-11,245,496",
            tracks:
                [
                    {
                        name: "Phase 3 WGS variants",
                        type: "variant",
                        format: "vcf",
                        visibilityWindow: 3000000,
                        url: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz",
                        indexURL: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz.tbi"
                    },
                    {
                        name: "Genes",
                        type: "annotation",
                        format: "bed",
                        url: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz",
                        indexURL: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz.tbi",
                        order: Number.MAX_VALUE,
                        visibilityWindow: 300000000,
                        displayMode: "EXPANDED"
                    }
                ]

        }

    var igvDiv = document.getElementById("igvDiv")

    window.igv = igv

    const browser = await igv.createBrowser(igvDiv, options)
    window.igvBrowser = browser

    browser.on('locuschange', referenceFrameList => {
      const facetsHtml = getFacetsHtml('Phase 3 WGS variants', browser)
      const filtersDom = document.querySelector('.filters')
      filtersDom.insertAdjacentHTML('beforeend', facetsHtml)
    })

</script>

</body>

</html>
