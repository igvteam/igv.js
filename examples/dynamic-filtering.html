<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="Jim Robinson" name="author">
    <link href=img/favicon.ico rel="shortcut icon">
    <title>igv.js</title>
    <style>.filters li { display: inline} </style>
    <script src="https://cdn.jsdelivr.net/npm/crossfilter2@1.5.4"></script>
    <script>

    const HISTOGRAM_BAR_MAX_HEIGHT = 20
    const SLIDER_HANDLEBAR_WIDTH = 6

    /** Render update to reflect newly-selected features in IGV track */
    function updateTrack(trackIndex, filteredFeatures, igv, igvBrowser) {
      igv.FeatureUtils.packFeatures(filteredFeatures)
      const range = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.range
      igvBrowser.trackViews[trackIndex].track.featureSource.featureCache =
        new igv.FeatureCache(filteredFeatures, igvBrowser.genome, range)

      igvBrowser.trackViews[trackIndex].track.clearCachedFeatures()
      igvBrowser.trackViews[trackIndex].track.updateViews()
    }

    /** Get unfiltered genomic features on current chromosome */
    function getOriginalChrFeatures(trackIndex, igvBrowser) {
      const chr = Array.from(igvBrowser.tracks[0].trackView.viewports[0].featureCache.features.keys())[0]

      if (
        typeof window.originalFeatures === 'undefined' ||
        chr in window.originalFeatures === false
      ) {
        window.originalFeatures = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.allFeatures
      }

      const originalChrFeatures = window.originalFeatures[chr]

      return originalChrFeatures
    }

    /** Determine if feature is in genomic frame */
    function getIsFeatureInFrame(feature, igvBrowser) {
      const frame = igvBrowser.referenceFrameList[0]

      const isFeatureInFrame = (
        // Contained:
        // Frame:     --------
        // Feature:     ----
        (feature.start >= frame.start && feature.end <= frame.end) ||

        // Overlaps start
        // Frame:     --------
        // Feature:  ----
        (feature.start <= frame.start && feature.end >= frame.start) ||

        // Overlaps end
        // Frame:     --------
        // Feature:         ----
        (feature.start <= frame.end && feature.end >= frame.end) ||

        // Spans
        // Frame:     --------
        // Feature: ------------
        (feature.start <= frame.start && feature.end >= frame.end)
      )

      return isFeatureInFrame
    }

    function getSelection() {

      const selection = {}

      const categoricalFilters = document.querySelectorAll('.igv-filter-categorical')
      categoricalFilters.forEach(input => {
        if (input.checked) {
          const facetName = input.getAttribute('data-facet-name')
          const filter = input.value
          if (facetName in selection) {
            selection[facetName].push(filter)
          } else {
            selection[facetName] = [filter]
          }
        }
      })

      const numericFacets = document.querySelectorAll('.igv-facet-numeric-query-builder')
      numericFacets.forEach(facet => {
        const facetName = facet.getAttribute('data-facet-name')
        const value = facet.querySelector('.igv-numeric-query-input-value').value
        const value2 = facet.querySelector('.igv-numeric-query-input-value2').value

        const operator = 'between'
        selection[facetName] = [[operator, [value, value2]]]
        // if (['between', 'not between'].includes(operator)) {
        //   numericFilters = [[operator, [value, value2]]]
        // } else {
        //   numericFilters = [[operator, value]]
        // }
      })

      return selection
    }

    /**
     * Determine if a feature satisfies any numeric filters
     *
     * @param {Number} d - A numeric datum; a numeric value for a feature
     * @param {Array<Array<String, *>>} numericFilters Filters for a numeric
     *   facet. Each filter has an operator and a value.  Values can be a number
     *   or an array of two numbers.
     *
     *   Example simple numeric filters:
     *   - ["=", 1.3]
     *   - ["!=", 1.3]
     *   - [">", 6]
     *   - [">=", 6]
     *   - ["<", 6]
     *   - ["<=", 6]
     *   - ["between", [5, 42]] -- inclusive, i.e. 5 <= d <= 42
     *   - ["not between", [5, 42]] -- inclusive, i.e. !(5 <= d <= 42)
     *
     *   Example compound numeric filters:
     *   - [["between", [95, 100]], ["between", [1200, 1300]] -- (95 <= d <= 100) or (1200 <= d <= 1300)
     *
     *   Compound numeric filters could be used to e.g.:
     *     - isolate the peaks of multimodal distributions (as in above concrete example)
     *     - isolate the tails of distributions
     *
     *   TODO:
     *   - Enable percentile filtering, i.e. beyond raw values.  Requires 1-time full sort, then trivial.
     *
     * @returns {Boolean} Whether feature datum passed any filters
     */
    function applyNumericFilters(d, rawFilters) {
      // const [numericFilters, includeNa] = rawFilters
      const numericFilters = rawFilters
      const includeNa = true

      if (includeNa && d === null) {return true}

      for (let i = 0; i < numericFilters.length; i++) {
        const [operator, value] = numericFilters[i]
        if (operator === '=') {
          // for fastest querying, exit function immediately upon _any_ condition
          // evaluating to true
          if (d === value) {return true}
        } else if (operator === '!=') {
          if (d !== value) {return true}
        } else if (operator === '>') {
          if (d > value) {return true}
        } else if (operator === '>=') {
          if (d >= value) {return true}
        } else if (operator === '<') {
          if (d < value) {return true}
        } else if (operator === '<=') {
          if (d <= value) {return true}
        } else if (operator === 'between') {
          if (value[0] <= d && d <= value[1]) {return true}
        } else if (operator === 'not between') {
          if (!(value[0] <= d && d <= value[1])) {return true}
        }
      }

      return false
    }

    function filterFeatures(trackSelector, filterResults, facets, igvBrowser) {
      const [filteredFeatures, filterCounts] = filterResults
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);
      const featuresInFrame = getFeaturesInFrame(trackSelector, igvBrowser)

      const featuresToPlot = []
      for (let i = 0; i < filteredFeatures.length; i++) {
        const rawIndex = filteredFeatures[i].rawIndex
        const featureToPlot = featuresInFrame[rawIndex]
        featuresToPlot.push(featureToPlot)
      }

      updateTrack(trackIndex, featuresToPlot, igv, igvBrowser)

      Object.entries(filterCounts).forEach(([facetName, countsByFilter], i) => {
        const facet = facets[i]
        Object.entries(countsByFilter).forEach(([filterName, count]) => {
          if (facet.type === 'categorical') {
            const filterSel =
              `.igv-filter-label[data-facet-name="${facet.name}"][data-filter-name="${filterName}"] ` +
              `.igv-filter-count`
            console.log('filterSel', filterSel)
            const countDom = document.querySelector(filterSel)
            countDom.textContent = count
          }
        })
      })
    }

    function getFeaturesInFrame(trackSelector, igvBrowser) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);
      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)
      const featuresInFrame = originalChrFeatures.filter(
        feature => getIsFeatureInFrame(feature, igvBrowser)
      )
      return featuresInFrame
    }

    /** Get index position of track in IGV browser, given its name or index */
    function getTrackIndex(trackSelector, igvBrowser) {
      let trackIndex = null
      if (typeof trackSelector === 'string') {
        igvBrowser.trackViews.find((trackView, i) => {
          trackIndex = i
          return trackView.track.config?.name === trackSelector
        })
      } else {
        trackIndex = trackSelector
      }
      return trackIndex
    }

    /** Get D3 scale to convert between numeric facet values and pixels */
    function getXScale(bars, histogramWidth, hasNull) {
      hasNull = true
      const barStartIndex = hasNull ? 2 : 0
      const valueDomain = []
      const pxRange = []
      for (let i = barStartIndex; i < bars.length; i++) {
        const bar = bars[i]
        valueDomain.push(bar.start)
        const x = bar.x + (hasNull ? 0 : SLIDER_HANDLEBAR_WIDTH + 2)
        pxRange.push(x)
      }
      const lastBar = bars.slice(-1)[0]
      valueDomain.push(lastBar.end)
      pxRange.push(histogramWidth + (hasNull ? 0 : SLIDER_HANDLEBAR_WIDTH))

      const xScale = scaleLinear(valueDomain, pxRange)
      return xScale
    }

    /** Get width and height for SVG elements for histogram */
    function getHistogramSvgDimensions(bars) {
      const lastBar = bars.slice(-1)[0]
      const histogramWidth = lastBar.x + lastBar.width
      const histogramHeight = HISTOGRAM_BAR_MAX_HEIGHT + 2
      return [histogramWidth, histogramHeight]
    }

    /** Histogram for distribution of numeric facet values, with tooltips or slider */
    function getHistogram(
      facet, bars, histogramWidth, histogramHeight, operator,
      brushSelection, handleBrushMove, handleBrushEnd
    ) {
      const sliderId = `numeric-filter-histogram-slider___${facet.name}`
      // const [sliderLeft, sliderWidth, extentStartX, extentWidth] = getSliderStyle(bars, histogramWidth)
      const handlebarY = -1 * (HISTOGRAM_BAR_MAX_HEIGHT - 1)



      return (`
          <svg
            height=${histogramHeight}
            width=${histogramWidth}
            style="border-bottom: 1px solid #AAA;"
            class="numeric-filter-histogram"
          >
            ${bars.map((bar, i) => {
              return (`
                <rect
                  fill=${bar.color}
                  x=${bar.x}
                  y=${bar.y}
                  width=${bar.width}
                  height=${bar.height}
                />`
              )
            }).join('')}
          </svg>`)

    }

    function getQuantiles(sortedNumbers, max, min, numBins=15) {
      const size = (max - min) / numBins
      const quantiles = new Array(numBins).fill(0)

      for (let i = 1; i < numBins + 1; i++) {
        const prevBinNum = min + (i - 1) * size
        const binNum = min + i * size
        for (let j = 0; j < sortedNumbers.length; j++) {
          const num = sortedNumbers[j]
          if (prevBinNum < num && num <= binNum) {
            quantiles[i - 1] += 1
          }
        }
      }

      return quantiles
    }

    function getStatistics(numbers) {
      // Sort the array in ascending order
      numbers.sort((a, b) => a - b);

      // Compute the sum using a loop for faster mean calculation
      let sum = 0;
      for (let i = 0; i < numbers.length; i++) {
          sum += numbers[i];
      }
      const mean = sum / numbers.length;

      const max = numbers[numbers.length - 1];
      const min = numbers[0];
      const median = getMedian(numbers);

      // Divide the array into two halves
      const midIndex = Math.floor(numbers.length / 2);
      const lowerHalf = numbers.slice(0, midIndex);
      const upperHalf = numbers.length % 2 === 0
          ? numbers.slice(midIndex)
          : numbers.slice(midIndex + 1);

      const q1 = getMedian(lowerHalf);
      const q3 = getMedian(upperHalf);

      const quantiles = getQuantiles(numbers, max, min)

      return { min, q1, median, q3, max, mean, quantiles };
    }

    /** Get display attributes for histogram bars */
    function getHistogramBarDisplayAttrs(bars, maxCount) {
      const barRectAttrs = []
      const maxHeight = HISTOGRAM_BAR_MAX_HEIGHT
      bars.forEach((barCount, i) => {
        const height = maxHeight * (barCount / maxCount)
        const width = 11
        const attrs = Object.assign({
          count: barCount,
          x: (width + 1) * i,
          y: maxHeight - height + 1,
          width,
          height,
          // color: (bar.isNull) ? '#888' : '#3D5A87'
          color: '#3D5A87'
        }, {})
        barRectAttrs.push(attrs)
      })
      return barRectAttrs
    }


    /** Get histogram to show with numeric filter */
    function getHistogramBars(facet) {
      let bars = facet.statistics.quantiles

      let maxCount = 0
      for (let i = 0; i < bars.length; i++) {
        const count = bars[i]
        if (count > maxCount) {maxCount = count}
      }

      bars = getHistogramBarDisplayAttrs(bars, maxCount)

      return bars
    }

    function getMedian(numbers) {
      const midIndex = Math.floor(numbers.length / 2);

      // If the array has an odd length, return the middle number
      if (numbers.length % 2 !== 0) {
        return numbers[midIndex];
      }

      // If the array has an even length, return the average of the two middle numbers
      return (numbers[midIndex - 1] + numbers[midIndex]) / 2;
    }

    /** Get crossfilter-initialized features by facet */
    function getFeaturesByFacet(features, facetNames) {
      const featureCrossfilter = crossfilter(features)
      window.featureCrossfilter = featureCrossfilter
      const featuresByFacet = {}
      for (let i = 0; i < facetNames.length; i++) {
        const facetName = facetNames[i]
        const facetCrossfilter = featureCrossfilter.dimension(d => d.facetIndex[i])
        featuresByFacet[facetName] = facetCrossfilter
      }
      return featuresByFacet
    }

    /** Get filtered feature results, and counts */
    function getFilteredFeatures(
      selection, featuresByFacet, facets, filterableFeatures
    ) {
      const t0 = Date.now()

      let fn; let facet; let results

      if (Object.keys(selection).length === 0) {
        results = filterableFeatures
      } else {
        for (let i = 0; i < facets.length; i++) {
          facet = facets[i]
          const facetName = facet.name
          if (facetName in selection) {
            if (facet.type === 'categorical') {
              // e.g. 'infant_sick_YN'
              const friendlyFilters = selection[facetName] // e.g. ['yes', 'NA']

              const filter = new Set()
              friendlyFilters.forEach(friendlyFilter => {
                const filterIndex = facet.filterNames.indexOf(friendlyFilter)
                filter.add(filterIndex)
              })

              fn = function(d, i) {
                return filter.has(d)
              }

              // Apply the actual crossfilter method
              featuresByFacet[facetName].filterFunction(fn)
            } else {
              const numericFilters = selection[facetName] // e.g. [0, 20]

              fn = function(d) {
                // return true
                return applyNumericFilters(d, numericFilters)
              }
              featuresByFacet[facetName].filterFunction(fn)
            }
          } else {
            fn = null
            // Apply the actual crossfilter method
            featuresByFacet[facetName].filter(fn)
          }
        }
        results = featuresByFacet[facet.name].top(Infinity)
      }

      const facetNames = facets.map(facet => facet.name)
      const t0Counts = Date.now()
      const counts = getFilterCounts(facetNames, featuresByFacet, facets, selection)

      console.log('in filterFeaturesNew, results', results)
      console.log('in filterFeaturesNew, counts', counts)
      return [results, counts]
    }

    /** Get counts for each filter, in each facet */
    function getFilterCounts(facetNames, featuresByFacet, facets, selection) {
      const filterCounts = {}

      for (let i = 0; i < facets.length; i++) {
        const facet = facets[i]
        const facetName = facet.name
        const facetCrossfilter = featuresByFacet[facetName]
        // Set counts for each filter in facet
        const rawFilterCounts = facetCrossfilter.group().top(Infinity)
        let countsByFilter

        if (facet.type === 'categorical') {
          countsByFilter = {}
          facet.filterNames.forEach((filterName, j) => {
            let count = null
            // check for originalGroups array first, if present
            const originalFilterNames = facets[i].originalFilterNames || facets[i].filterNames
            const filterNameIdx = originalFilterNames.indexOf(filterName)
            const rawFilterKeyAndValue = rawFilterCounts.find(rfc => rfc.key === filterNameIdx)
            if (rawFilterKeyAndValue) {
              count = rawFilterKeyAndValue.value
            }
            countsByFilter[filterName] = count
          })
        } else {
          countsByFilter = []
          for (let j = 0; j < rawFilterCounts.length; j++) {
            // For numeric facets, `rawFilterCounts` is an array of objects, where
            // each object is a distinct numeric value observed in the facet;
            // the `key` of this object is the numeric value, and the `value` is
            // how many features were observed with that numeric value.
            const countObject = rawFilterCounts[j]
            const filterValueAndCount = [countObject.key, countObject.value]
            countsByFilter.push(filterValueAndCount)
          }

          // Sort array by numeric value, to aid later histogram, etc.
          countsByFilter = countsByFilter.sort((a, b) => a[0] - b[0])
        }
        filterCounts[facet.name] = countsByFilter
      }

      // If a filter has been deselected, set its count to 0
      if (selection) {
        Object.entries(filterCounts).forEach(([facetName, countsByFilter]) => {
          Object.entries(countsByFilter).forEach(([filterName, count]) => {
            let newCount = count
            if (!(facetName in selection && selection[facetName]?.includes(filterName))) {
              newCount = 0
            }
            filterCounts[facetName][filterName] = newCount
          })
        })
      }

      return filterCounts
    }

    function initCrossfilter(facetsContainer) {
      const facets = facetsContainer.facets
      const rawFeatures = facetsContainer.features
      const facetNames = facets.map(facet => facet.name)
      const features = []

      for (let i = 0; i < rawFeatures.length; i++) {
        const feature = { 'rawIndex': i }

        // For categorical facets, we have an array of integers, e.g. [6, 0, 7, 0, 0].
        // Each element in the array is the index-offset of the feature's category assignment
        // for the facet at that index.
        const facetIndex = rawFeatures[i]
        feature.facetIndex = facetIndex
        features.push(feature)
      }

      const featuresByFacet = getFeaturesByFacet(features, facetNames)

      const filterCounts = {} // getFilterCounts(facetNames, featuresByFacet, facets, null)

      return {
        features, featuresByFacet, facets,
        filterCounts
      }
    }

    /**
     * Initialize facets and filters for the current genomic frame
     *
     * Output:
     * {
     *   "features": [
     *      // Each "feature" (e.g. variant, read, gene) is represented as an
     *      // array of numbers.  For categorical facets, each number is a
     *      // compact representation (e.g. 0) of the filter / value (e.g.
     *      // "SNP") of a particular facet / dimension (e.g. "VT").
     *      [<Number>]
     *    ],
     *   "facets": [
     *     {
     *       "name": <String>, // Internal name of facet, e.g. "VT"
     *
     *       "displayName": <String>, // e.g. "Variant type" TODO
     *
     *       "type": <String> // "categorical" or "integer" or "float"
     *
     *       // For categorical: names of filters in facet
     *       // The index of these names correspond to the integer value at the
     *       // appropriate position in the `features` array.
     *       "filterNames": [<String>],
     *
     *       // For categorical: number of features satisfying each filter
     *       "countsByFilterName": {
     *          <String>: <Integer>
     *       }
     *
     *      // For integer or float: numeric values observed for this facet
     *      "filterNumbers": [<Number>],
     *
     *      "statistics": {
     *        "min": <Number>,
     *        "q1": <Number>,
     *        "median": <Number>,
     *        "q3": <Number>,
     *        "max": <Number>
     *      }
     *     }
     *   ]
     * }
     */
    function initFacets(trackSelector, igvBrowser) {
      const t0 = Date.now()
      const trackIndex = getTrackIndex(trackSelector, igvBrowser)
      const featuresInFrame = getFeaturesInFrame(trackIndex, igvBrowser)
      console.log('featuresInFrame[0]', featuresInFrame[0])

      // Populate facets model, except for filterNames array values
      let facets = []
      const headInfo = featuresInFrame[0].header.INFO
      console.log('headInfo', headInfo)
      const dimensions = Object.keys(headInfo);
      dimensions.forEach(dimension => {
        const igvFacet = headInfo[dimension]
        // string, flag, integer, or float
        const igvType = igvFacet.Type.toLowerCase()
        const type = ['string', 'flag'].includes(igvType) ? 'categorical' : igvType
        const description = igvFacet.Description
        const facet = {'name': dimension, type, description}
        if (type === 'categorical') {
          facet.filterNames = []
          facet.countsByFilterName = {}
        } else {
          facet.filterNumbers = []
          facet.statistics = {}
        }
        facets.push(facet)
      })

      // Populate features, and (for each facet) filterNames
      let features = []
      for (let i = 0; i < featuresInFrame.length; i++) {
        const feature = []
        const igvFeature = featuresInFrame[i]
        const info = igvFeature.info
        let j = 0
        for (facetName in headInfo) {
          let value
          if (facetName in info === false) {
            // Use an "empty" value if the feature lacks a value
            // for this dimension, which is pretty common.
            value = undefined
          } else {
            const rawValue = info[facetName]
            const facet = facets[j]
            if (facet.type === 'categorical') {
              if (!facet.filterNames.includes(rawValue)) {
                // Populate filterNames
                facet.filterNames.push(rawValue);
                facet.countsByFilterName[rawValue] = 0
              }

              // Using index offsets as values, rather than raw strings, helps
              // make categorical filtering fast.
              value = facet.filterNames.indexOf(rawValue)
              facet.countsByFilterName[rawValue] += 1
            } else {
              const isFloat = facet.type === 'float'
              value = isFloat ? parseFloat(rawValue) : parseInt(rawValue)
              facet.filterNumbers.push(value)
            }
            facets[j] = facet
          }
          feature.push(value)
          j++
        }

        // Populate features
        features.push(feature)
      }

      const undefinedIndexes = new Set()

      const untrimmedFacets = facets
      // Trim unused facets
      facets = facets.filter((facet, i) => {
        if (
          (facet.type === 'categorical' && facet.filterNames.length < 2) ||
          (facet.type !== 'categorical' && facet.filterNumbers.length < 2)
        ) {
          undefinedIndexes.add(i)
          return false
        } else {
          return true
        }
      })

      const untrimmedToTrimmedFacetIndexMap = {}
      untrimmedFacets.forEach((untrimmedFacet, i) => {
        facets.forEach((facet, j) => {
          if (untrimmedFacet.name === facet.name) {
            untrimmedToTrimmedFacetIndexMap[i] = j
          }
        })
      })

      // Trim undefined indexes from features
      if (undefinedIndexes.size > 0) {
        const trimmedFeatures = []
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          const trimmedFeature = []
          for (let j = 0; j < feature.length; j++) {
            if (!undefinedIndexes.has(j)) { // If this facet isn't totally empty
              let featureValue = feature[j]

              // Handle facets where _some but not all_ values are not available
              if (featureValue === undefined) {
                featureValue = null
                const k = untrimmedToTrimmedFacetIndexMap[j]
                // console.log('j, k, facets[k], facets, feature, i', j, k, facets[k], facets, feature, i)
                if (facets[k].type === 'categorical') {
                  if (!facets[k].filterNames.includes(null)) {
                    facets[k].filterNames.push(null)
                    facets[k].countsByFilterName[null] = 1
                  } else {
                    facets[k].countsByFilterName[null] += 1
                  }
                }
              }
              trimmedFeature.push(featureValue)
            }
          }
          trimmedFeatures.push(trimmedFeature)
        }
        features = trimmedFeatures
      }

      console.log('facets', facets)
      console.log('features[814]', features[814])
      console.log('features[815]', features[815])

      // Populate statistics for numeric facets
      facets = facets.map(facet => {
        if (facet.type === 'categorical') return facet

        const {min, q1, median, q3, max, mean, quantiles} =
          getStatistics(facet.filterNumbers)
        facet.statistics = {min, q1, median, q3, max, mean, quantiles}

        return facet
      })

      const t1 = Date.now()
      console.log('initFacets duration (ms):', (t1 - t0))
      return {facets, features}
    }

    function getCategoricalFacetHtml(facet, isPartlyCollapsed=true) {
      // Categorical facets need > 1 filter to be useful
      const numFilters = facet.filterNames.length
      if (numFilters < 2) return ''

      let filters = facet.filterNames;

      // Get list of filter checkboxes
      const filtersHtml = filters.map((filterName, i) => {
        let style = ''
        if (isPartlyCollapsed && i >= 5) style = 'display: none;'

        const facetFilterAttrs = `
          data-facet-name="${facet.name}"
          data-filter-name="${filterName}"`

        const fullName = `${facet.name}:${filterName}`
        const attrs = `
          value="${filterName}"
          name="${fullName}"
          class="igv-filter igv-filter-categorical"
          ${facetFilterAttrs}
        `
        const count = facet.countsByFilterName[filterName]
        const filterHtml = `
          <label class="igv-filter-label" style="${style}" ${facetFilterAttrs}>
            <div>
              <input type="checkbox" ${attrs} checked />
              <span class="igv-filter-label-text">${filterName}</span>
              <span class="igv-filter-label-quantities">
                <span class="igv-filter-count">${count}</span>
              </span>
            </div>
          </label>`
        return filterHtml
      }).join('')


      let moreOrLess = ''
      if (numFilters > 5) {
        moreOrLess = `
          <a
            class="igv-facet-toggle"
            onClick=""
          >
            ${isPartlyCollapsed ? 'More...' : 'Less...'}
          </a>`
        }

      const facetSel = `igv-facet-${facet.name}`
      // Add a facet header to the filters
      const facetHtml = `
        <div class="igv-facet ${facetSel}" style="width: 250px; float: left;">
          <span class="igv-facet-header">${facet.name}</span>
          ${filtersHtml}
          ${moreOrLess}
        </div>`

      return facetHtml
    }

    function updateInputValue(event) {
      const target = event.target
      const facetName = target.name.split(':')[0]
      filterFeatures('Phase 3 WGS variants', facetName)
    }

    function getNumericQueryInput(value, facet, filterName, style) {
      return `
        <input
          type="text"
          class="igv-filter igv-numeric-query-input igv-numeric-query-input-${filterName}"
          name="${facet.name}:${filterName}"
          value="${value}"
          style="width: ${style.width}; font-size: ${style.fontSize};"
        />`
    }

    function getNumericQueryBuilder(facet, filterNumbers, statistics) {
      const inputValue = statistics.min
      const inputValue2 = statistics.max
      const operator = 'and'
      const precision = 2
      const styles = getResponsiveStyles(inputValue, inputValue2, operator, precision)

      const bars = getHistogramBars(facet)
      const histogram = getHistogram(facet, bars, 150, 20, 'between')

      const input = getNumericQueryInput(statistics.min, facet, 'value', styles.input)
      const input2 = getNumericQueryInput(statistics.max, facet, 'value2', styles.input2)

      return `
        <div
          class="igv-facet-numeric-query-builder"
          data-facet-name="${facet.name}"
        >
          ${histogram}
          <div class="igv-facet-numeric-inputs-container">
            ${input}
            ${input2}
          </div>
        </div>`

    }

    /**
     * Round, source: https://stackoverflow.com/a/18358056
     *
     * @param {number} val
     * @param {number} [precision]
     * @return {number}
     */
    function round(val, precision = 0) {
      return +(`${Math.round(`${val}e+${precision}`)}e-${precision}`)
    }

    /**
     * Get width and font size for input, to help keep full value glanceable
     */
    function getInputStyle(inputValue, operator, precision) {
      let width = 37
      let fontSize = 13

      const roundedNumber = round(inputValue, precision)
      const stringValue = roundedNumber.toString()
      let numDigits = stringValue.length
      if (stringValue.includes('.')) {numDigits -= 0.75}

      if (
        numDigits > 4 &&
            (!['between', 'not between'].includes(operator) || numDigits <= 7)
      ) {
        fontSize = 12
        width += 6 * (numDigits - 4)
      } else if (numDigits > 7) {
        fontSize = 11
        width += 5.5 * (numDigits - 4)
      }

      const style = {
        width: `${width}px`,
        fontSize: `${fontSize}px`,
        numDigits // Not a standard style, but a helpful prop
      }

      return style
    }

    /** Make big input numbers fit on one more more often */
    function getResponsiveStyles(inputValue, inputValue2, operator, precision) {
      const inputStyle = getInputStyle(inputValue, operator, precision)
      const inputStyle2 = getInputStyle(inputValue2, operator, precision)
      const andStyle = { marginLeft: '4px' }
      const totalDigits = inputStyle.numDigits + inputStyle2.numDigits
      if (totalDigits > 14) {
        andStyle.marginLeft = '2px'
        andStyle.marginRight = '-2px'
        if (totalDigits > 16) {andStyle.fontSize = 11.5}
      }
      const styles = {
        input: inputStyle,
        input2: inputStyle2,
        and: andStyle
      }
      return styles
    }

    function getNumericFacetHtml(facet) {
      if (
        facet.filterNumbers.length === 0 ||
        facet.statistics.min === facet.statistics.max
      ) {
        return ''
      }

      const filterNumbers = facet.filterNumbers
      const statistics = facet.statistics

      const filtersHtml = getNumericQueryBuilder(facet, filterNumbers, statistics)

      const facetSel = `igv-facet-${facet.name}`
      const facetHtml = `
        <div class="igv-facet ${facetSel}" style="width: 250px; float: left;">
          <span class="igv-facet-header">${facet.name}</span>
          ${filtersHtml}
        </div>`

      return facetHtml
    }

    function getFacetsHtml(facetsContainer) {
      const facetList = facetsContainer.facets.map(facetContainer => {
        let facetHtml
        if (facetContainer.type === 'categorical') {
          facetHtml = getCategoricalFacetHtml(facetContainer)
        } else {
          facetHtml = getNumericFacetHtml(facetContainer)
        }
        return facetHtml
      }).join('')

      const facetsHtml = `<div>${facetList}</div>`
      return facetsHtml
    }

    function initIgvFacets(browser) {
      const trackSelector = 'Phase 3 WGS variants'
      const facetsContainer = initFacets(trackSelector, browser)
      const facetsHtml = getFacetsHtml(facetsContainer)

      const filterContainerDom = document.querySelector('.filters')
      filterContainerDom.innerHTML = ''
      filterContainerDom.insertAdjacentHTML('beforeend', facetsHtml)

      const {
        features, featuresByFacet, facets,
        filterCounts
      } = initCrossfilter(facetsContainer)

      window.facets = facets

      window.features = features
      window.featuresByFacet = featuresByFacet

      const filtersDom = document.querySelectorAll('.igv-filter')
      filtersDom.forEach(filterDom => {
        filterDom.addEventListener('change', (event) => {

          const selection = getSelection()
          const facetName = filterDom.getAttribute('data-facet-name')
          const filterResults =
            getFilteredFeatures(selection, featuresByFacet, facets, features)

          filterFeatures(trackSelector, filterResults, facets, igvBrowser)

          // filterFeatures(trackSelector, facetName)
        })
      })
    }

  </script>
</head>

<body>

<h1>Ad-hoc filtering in IGV</h1>
<ul class="filters" style="float: left;">
</ul>


<div id="igvDiv" style="padding-top: 10px;padding-bottom: 10px; border:1px solid lightgray; clear: both;"></div>

<script type="module">

    import igv from "../js/index.js"

    const options =
        {
            // Example of fully specifying a reference .  We could alternatively use  "genome: 'hg19'"
            reference: {
                "id": "hg19",
                "name": "Human (CRCh37/hg19)",
                "fastaURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta",
                "indexURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta.fai",
                "cytobandURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/cytoBand.txt"
            },
            locus: "19:11,199,138-11,245,496",
            tracks:
                [
                    {
                        name: "Phase 3 WGS variants",
                        type: "variant",
                        format: "vcf",
                        visibilityWindow: 3000000,
                        url: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz",
                        indexURL: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz.tbi"
                    },
                    {
                        name: "Genes",
                        type: "annotation",
                        format: "bed",
                        url: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz",
                        indexURL: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz.tbi",
                        order: Number.MAX_VALUE,
                        visibilityWindow: 300000000,
                        displayMode: "EXPANDED"
                    }
                ]

        }

    var igvDiv = document.getElementById("igvDiv")

    window.igv = igv

    const browser = await igv.createBrowser(igvDiv, options)
    window.igvBrowser = browser

    function handleFirstFeaturesLoaded(track) {
      initIgvFacets(browser)
      browser.off('featuresloaded', handleFirstFeaturesLoaded) // Remove event listener
    }

    browser.on('featuresloaded', handleFirstFeaturesLoaded)

    browser.on('locuschange', () => {
      initIgvFacets(browser)
    })

</script>

</body>

</html>
