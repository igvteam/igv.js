<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="Jim Robinson" name="author">
    <link href=img/favicon.ico rel="shortcut icon">
    <title>igv.js</title>
    <style>.filters li { display: inline} </style>
    <script src="https://cdn.jsdelivr.net/npm/crossfilter2@1.5.4"></script>
    <script>

    /** Render update to reflect newly-selected features in IGV track */
    function updateTrack(trackIndex, filteredFeatures, igv, igvBrowser) {
      igv.FeatureUtils.packFeatures(filteredFeatures)
      const range = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.range
      igvBrowser.trackViews[trackIndex].track.featureSource.featureCache =
        new igv.FeatureCache(filteredFeatures, igvBrowser.genome, range)

      igvBrowser.trackViews[trackIndex].track.clearCachedFeatures()
      igvBrowser.trackViews[trackIndex].track.updateViews()
    }

    /** Get unfiltered genomic features on current chromosome */
    function getOriginalChrFeatures(trackIndex, igvBrowser) {
      const chr = Array.from(igvBrowser.tracks[0].trackView.viewports[0].featureCache.features.keys())[0]

      console.log('igvBrowser.tracks[0]', igvBrowser.tracks[0])
      console.log('chr', chr)

      if (
        typeof window.originalFeatures === 'undefined' ||
        chr in window.originalFeatures === false
      ) {
        window.originalFeatures = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.allFeatures
      }

      const originalChrFeatures = window.originalFeatures[chr]

      return originalChrFeatures
    }

    /** Determine if feature is in genomic frame */
    function getIsFeatureInFrame(feature, igvBrowser) {
      const frame = igvBrowser.referenceFrameList[0]

      const isFeatureInFrame = (
        // Contained:
        // Frame:     --------
        // Feature:     ----
        (feature.start >= frame.start && feature.end <= frame.end) ||

        // Overlaps start
        // Frame:     --------
        // Feature:  ----
        (feature.start <= frame.start && feature.end >= frame.start) ||

        // Overlaps end
        // Frame:     --------
        // Feature:         ----
        (feature.start <= frame.end && feature.end >= frame.end) ||

        // Spans
        // Frame:     --------
        // Feature: ------------
        (feature.start <= frame.start && feature.end >= frame.end)
      )

      return isFeatureInFrame
    }

    function getSelection() {

      const selection = {}

      const categoricalFilters = document.querySelectorAll('.igv-filter-categorical')
      console.log('categoricalFilters', categoricalFilters)
      categoricalFilters.forEach(input => {
        if (input.checked) {
          const facetName = input.getAttribute('data-facet-name')
          const filter = input.value
          if (facetName in selection) {
            selection[facetName].push(filter)
          } else {
            selection[facetName] = [filter]
          }
        }
      })

      const numericFacets = document.querySelectorAll('.igv-facet-numeric-query-builder')
      numericFacets.forEach(facet => {
        const facetName = facet.getAttribute('data-facet-name')
        const value = facet.querySelector('.igv-numeric-query-input-value').value
        const value2 = facet.querySelector('.igv-numeric-query-input-value2').value

        const operator = 'between'
        selection[facetName] = [[operator, [value, value2]]]
        // if (['between', 'not between'].includes(operator)) {
        //   numericFilters = [[operator, [value, value2]]]
        // } else {
        //   numericFilters = [[operator, value]]
        // }
      })

      console.log('in getSelection, selection', selection)
      return selection
    }

    function filterFeatures(trackSelector, facetName) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);

      const selection = {}

      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)

      const facetSel = `.igv-facet-${facetName}`
      const inputs = document.querySelectorAll(`.filters ${facetSel} input`)
      console.log('in filterFeatures, inputs', inputs)

      const facets = {}

      inputs.forEach(input => {
        if (input.checked) {
          const filter = input.value
          if (!facets[facetName]?.includes(filter)) {
            if (facet in selection) {
              selection[facetName].push(filter)
            } else {
              selection[facetName] = [filter]
            }
          }
        } else if (input.type === 'text') {

        }
      })

      console.log('in filterFeatures, facets', facets)

      if (selection.size === 0) {
        return selection.originalChrFeatures
      }

      // Filter features by selection (i.e., selected facets and filters)
      const [newFilteredFeatures, newFilterCounts] = filterFeaturesNew(
        selection, featuresByFacet, initFacets, originalChrFeatures, rawFacets
      )

      const filteredFeatures = originalChrFeatures.filter(
        feature => selection.has(feature.info[dimension]) && getIsFeatureInFrame(feature, igvBrowser)
      )

      console.log('filteredFeatures', filteredFeatures)
      updateTrack(trackIndex, filteredFeatures, igv, igvBrowser)
    }

    function getFeaturesInFrame(trackSelector, igvBrowser) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);
      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)
      const featuresInFrame = originalChrFeatures.filter(
        feature => getIsFeatureInFrame(feature, igvBrowser)
      )
      return featuresInFrame
    }

    /** Get index position of track in IGV browser, given its name or index */
    function getTrackIndex(trackSelector, igvBrowser) {
      let trackIndex = null
      if (typeof trackSelector === 'string') {
        igvBrowser.trackViews.find((trackView, i) => {
          trackIndex = i
          return trackView.track.config?.name === trackSelector
        })
      } else {
        trackIndex = trackSelector
      }
      return trackIndex
    }

    function getStatistics(numbers) {
      // Sort the array in ascending order
      numbers.sort((a, b) => a - b);

      // Compute the sum using a loop for faster mean calculation
      let sum = 0;
      for (let i = 0; i < numbers.length; i++) {
          sum += numbers[i];
      }
      const mean = sum / numbers.length;

      const max = numbers[numbers.length - 1];
      const min = numbers[0];
      const median = getMedian(numbers);

      // Divide the array into two halves
      const midIndex = Math.floor(numbers.length / 2);
      const lowerHalf = numbers.slice(0, midIndex);
      const upperHalf = numbers.length % 2 === 0
          ? numbers.slice(midIndex)
          : numbers.slice(midIndex + 1);

      const q1 = getMedian(lowerHalf);
      const q3 = getMedian(upperHalf);

      return { min, q1, median, q3, max, mean };
    }

    function getMedian(numbers) {
      const midIndex = Math.floor(numbers.length / 2);

      // If the array has an odd length, return the middle number
      if (numbers.length % 2 !== 0) {
        return numbers[midIndex];
      }

      // If the array has an even length, return the average of the two middle numbers
      return (numbers[midIndex - 1] + numbers[midIndex]) / 2;
    }

    /** Get crossfilter-initialized features by facet */
    function getFeaturesByFacet(features, facetNames) {
      console.log('in getFeaturesByFacet, features', features)
      const featureCrossfilter = crossfilter(features)
      window.featureCrossfilter = featureCrossfilter
      console.log('in getFeaturesByFacet, featureCrossfilter', featureCrossfilter)
      const featuresByFacet = {}
      for (let i = 0; i < facetNames.length; i++) {
        const facetName = facetNames[i]
        const facetCrossfilter = featureCrossfilter.dimension(d => d.facetIndex[i])
        featuresByFacet[facetName] = facetCrossfilter
      }
      return featuresByFacet
    }

    /** Get filtered feature results */
    function filterFeaturesNew(
      selection, featuresByFacet, initFacets, filterableFeatures, rawFacets
    ) {
      const t0 = Date.now()
      const facets = initFacets

      console.log('in filterFeaturesNew, featuresByFacet', featuresByFacet)

      let fn; let facet; let results

      if (Object.keys(selection).length === 0) {
        results = filterableFeatures
      } else {
        for (let i = 0; i < facets.length; i++) {
          facet = facets[i]
          if (facet in selection) {
            if (facet.type === 'categorical') {
              // e.g. 'infant_sick_YN'
              const friendlyFilters = selection[facet] // e.g. ['yes', 'NA']

              const filter = new Set()
              friendlyFilters.forEach(friendlyFilter => {
                // find the original index of the filter in the source facet as the list here may be trimmed already
                const sourceFacet = rawFacets.find(f => f.name === facet)
                const filterIndex = sourceFacet.groups.indexOf(friendlyFilter)
                filter.add(filterIndex)
              })

              fn = function(d) {
                return filter.has(d)
              }

              // Apply the actual crossfilter method
              featuresByFacet[facet].filterFunction(fn)
            } else {
              const numericFilters = selection[facet] // e.g. [0, 20]

              fn = function(d) {
                return applyNumericFilters(d, numericFilters)
              }
              featuresByFacet[facet].filterFunction(fn)
            }
          } else {
            fn = null
            // Apply the actual crossfilter method
            featuresByFacet[facet].filter(fn)
          }
        }
        results = featuresByFacet[facet].top(Infinity)
      }

      const facetNames = initFacets.map(facet => facet.name)
      const t0Counts = Date.now()
      const counts = getFilterCounts(facetNames, featuresByFacet, initFacets, selection)

      return [results, counts]
    }

    /** Get counts for each filter, in each facet */
    function getFilterCounts(facetNames, featuresByFacet, facets, selection) {
      const filterCounts = {}

      for (let i = 0; i < facetNames.length; i++) {
        const facet = facetNames[i]
        const facetCrossfilter = featuresByFacet[facet]
        // Set counts for each filter in facet
        const rawFilterCounts = facetCrossfilter.group().top(Infinity)
        let countsByFilter

        if (facet.includes('--group--')) {
          countsByFilter = {}
          facets[i].groups?.forEach((group, j) => {
            let count = null
            // check for originalGroups array first, if present
            const originalGroups = facets[i].originalGroups || facets[i].groups
            const groupIdx = originalGroups.indexOf(group)
            const rawFilterKeyAndValue = rawFilterCounts.find(rfc => rfc.key === groupIdx)
            if (rawFilterKeyAndValue) {
              count = rawFilterKeyAndValue.value
            }
            countsByFilter[group] = count
          })
        } else {
          countsByFilter = []
          for (let j = 0; j < rawFilterCounts.length; j++) {
            // For numeric facets, `rawFilterCounts` is an array of objects, where
            // each object is a distinct numeric value observed in the facet;
            // the `key` of this object is the numeric value, and the `value` is
            // how many features were observed with that numeric value.
            const countObject = rawFilterCounts[j]
            const filterValueAndCount = [countObject.key, countObject.value]
            countsByFilter.push(filterValueAndCount)
          }

          // Sort array by numeric value, to aid later histogram, etc.
          countsByFilter = countsByFilter.sort((a, b) => a[0] - b[0])
        }
        filterCounts[facet] = countsByFilter
      }

      // If a filter has been deselected, set its count to 0
      if (selection) {
        Object.entries(filterCounts).forEach(([facet, countsByFilter]) => {
          Object.entries(countsByFilter).forEach(([filter, count]) => {
            let newCount = count
            if (!(facet in selection && selection[facet]?.includes(filter))) {
              newCount = 0
            }
            filterCounts[facet][filter] = newCount
          })
        })
      }

      return filterCounts
    }

    function initCrossfilter(facetsContainer) {
      const facets = facetsContainer.facets
      const rawFeatures = facetsContainer.features
      const facetNames = facets.map(facet => facet.name)
      const features = []

      for (let i = 0; i < rawFeatures.length; i++) {
        const feature = {}

        // For categorical facets, we have an array of integers, e.g. [6, 0, 7, 0, 0].
        // Each element in the array is the index-offset of the feature's category assignment
        // for the facet at that index.
        const facetIndex = rawFeatures[i]
        feature.facetIndex = facetIndex
        features.push(feature)
      }

      const featuresByFacet = getFeaturesByFacet(features, facetNames)

      const filterCounts = getFilterCounts(facetNames, featuresByFacet, facets, null)

      return {
        features, featuresByFacet, loadedFacets: facets,
        filterCounts
      }
    }

    /**
     * Initialize facets and filters for the current genomic frame
     *
     * Output:
     * {
     *   "features": [
     *      // Each "feature" (e.g. variant, read, gene) is represented as an
     *      // array of numbers.  For categorical facets, each number is a
     *      // compact representation (e.g. 0) of the filter / value (e.g.
     *      // "SNP") of a particular facet / dimension (e.g. "VT").
     *      [<Number>]
     *    ],
     *   "facets": [
     *     {
     *       "name": <String>, // Internal name of facet, e.g. "VT"
     *
     *       "displayName": <String>, // e.g. "Variant type" TODO
     *
     *       "type": <String> // "categorical" or "integer" or "float"
     *
     *       // For categorical: names of filters in facet
     *       // The index of these names correspond to the integer value at the
     *       // appropriate position in the `features` array.
     *       "filterNames": [<String>],
     *
     *       // For categorical: number of features satisfying each filter
     *       "countsByFilterName": {
     *          <String>: <Integer>
     *       }
     *
     *      // For integer or float: numeric values observed for this facet
     *      "filterNumbers": [<Number>],
     *
     *      "statistics": {
     *        "min": <Number>,
     *        "q1": <Number>,
     *        "median": <Number>,
     *        "q3": <Number>,
     *        "max": <Number>
     *      }
     *     }
     *   ]
     * }
     */
    function initFacets(trackSelector, igvBrowser) {
      const t0 = Date.now()
      const trackIndex = getTrackIndex(trackSelector, igvBrowser)
      const featuresInFrame = getFeaturesInFrame(trackIndex, igvBrowser)

      // Populate facets model, except for filterNames array values
      let facets = []
      const headInfo = featuresInFrame[0].header.INFO
      console.log('headInfo', headInfo)
      const dimensions = Object.keys(headInfo);
      dimensions.forEach(dimension => {
        const igvFacet = headInfo[dimension]
        // string, flag, integer, or float
        const igvType = igvFacet.Type.toLowerCase()
        const type = ['string', 'flag'].includes(igvType) ? 'categorical' : igvType
        const description = igvFacet.Description
        const facet = {'name': dimension, type, description}
        if (type === 'categorical') {
          facet.filterNames = []
          facet.countsByFilterName = {}
        } else {
          facet.filterNumbers = []
          facet.statistics = {}
        }
        facets.push(facet)
      })

      // Populate features, and (for each facet) filterNames
      let features = []
      for (let i = 0; i < featuresInFrame.length; i++) {
        const feature = []
        const igvFeature = featuresInFrame[i]
        const info = igvFeature.info
        let j = 0
        for (facetName in headInfo) {
          let value
          if (facetName in info === false) {
            // Use an "empty" value if the feature lacks a value
            // for this dimension, which is pretty common.
            value = undefined
          } else {
            const rawValue = info[facetName]
            const facet = facets[j]
            if (facet.type === 'categorical') {
              if (!facet.filterNames.includes(rawValue)) {
                // Populate filterNames
                facet.filterNames.push(rawValue);
                facet.countsByFilterName[rawValue] = 0
              }

              // Using index offsets as values, rather than raw strings, helps
              // make categorical filtering fast.
              value = facet.filterNames.indexOf(rawValue)
              facet.countsByFilterName[rawValue] += 1
            } else {
              const isFloat = facet.type === 'float'
              value = isFloat ? parseFloat(rawValue) : parseInt(rawValue)
              facet.filterNumbers.push(value)
            }
            facets[j] = facet
          }
          feature.push(value)
          j++
        }

        // Populate features
        features.push(feature)
      }

      const undefinedIndexes = new Set()

      // Trim unused facets
      facets = facets.filter((facet, i) => {
        if (
          (facet.type === 'categorical' && facet.filterNames.length < 2) ||
          (facet.type !== 'categorical' && facet.filterNumbers.length < 2)
        ) {
          undefinedIndexes.add(i)
          return false
        } else {
          return true
        }
      })

      // Trim undefined indexes from features
      if (undefinedIndexes.length > 0) {
        const trimmedFeatures = []
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          const trimmedFeature = []
          for (let j = 0; j < features.length; j++) {
            if (!undefinedIndexes.has(j)) {
              trimmedFeature.push(feature[j])
            }
          }
          trimmedFeatures.push(trimmedFeature)
        }
        features = trimmedFeatures
      }

      // Populate statistics for numeric facets
      facets = facets.map(facet => {
        if (facet.type === 'categorical') return facet

        const {min, q1, median, q3, max, mean} = getStatistics(facet.filterNumbers)
        facet.statistics = {min, q1, median, q3, max, mean}

        return facet
      })

      const t1 = Date.now()
      console.log('initFacets duration (ms):', (t1 - t0))
      console.log('in initFacets, facets', facets)
      console.log('in initFacets, features', features)
      return {facets, features}
    }

    function getCategoricalFacetHtml(facet, isPartlyCollapsed=true) {
      // Categorical facets need > 1 filter to be useful
      const numFilters = facet.filterNames.length
      if (numFilters < 2) return ''

      let filters = facet.filterNames;
      if (isPartlyCollapsed) filters = filters.slice(0, 5)

      // Get list of filter checkboxes
      const filtersHtml = filters.map(filterName => {
        const fullName = `${facet.name}:${filterName}`
        const attrs = `
          value="${filterName}"
          name="${fullName}"
          class="igv-filter igv-filter-categorical"
          data-facet-name="${facet.name}"
          data-filter-name="${filterName}"
        `
        const count = facet.countsByFilterName[filterName]
        const filterHtml = `
          <label class="igv-filter-label">
            <div>
              <input type="checkbox" ${attrs} checked />
              <span class="igv-filter-label-text">${filterName}</span>
              <span class="igv-filter-label-quantities">
                <span class="igv-filter-count">${count}</span>
              </span>
            </div>
          </label>`
        return filterHtml
      }).join('')


      let moreOrLess = ''
      if (numFilters > 5) {
        moreOrLess = `
          <a
            class="igv-facet-toggle"
            onClick=""
          >
            ${isPartlyCollapsed ? 'More...' : 'Less...'}
          </a>`
        }

      const facetSel = `igv-facet-${facet.name}`
      // Add a facet header to the filters
      const facetHtml = `
        <div class="igv-facet ${facetSel}" style="width: 250px; float: left;">
          <span class="igv-facet-header">${facet.name}</span>
          ${filtersHtml}
          ${moreOrLess}
        </div>`

      // console.log('facetHtml', facetHtml)
      return facetHtml
    }

    function updateInputValue(event) {
      console.log('updateInputValue, event', event)
      const target = event.target
      console.log('target', target)
      console.log('target.value', target.value)
      const facetName = target.name.split(':')[0]
      filterFeatures('Phase 3 WGS variants', facetName)
    }

    function getNumericQueryInput(value, facet, filterName, style) {
      return `
        <input
          type="text"
          class="igv-filter igv-numeric-query-input igv-numeric-query-input-${filterName}"
          name="${facet.name}:${filterName}"
          value="${value}"
          style="width: ${style.width}; font-size: ${style.fontSize};"
          onChange=updateInputValue(event)
        />`
    }

    function getNumericQueryBuilder(facet, filterNumbers, statistics) {
      const inputValue = statistics.min
      const inputValue2 = statistics.max
      const operator = 'and'
      const precision = 2
      const styles = getResponsiveStyles(inputValue, inputValue2, operator, precision)

      const input = getNumericQueryInput(statistics.min, facet, 'value', styles.input)
      const input2 = getNumericQueryInput(statistics.max, facet, 'value2', styles.input2)

      return `
        <div
          class="igv-facet-numeric-query-builder"
          data-facet-name="${facet.name}"
        >
          <div class="igv-facet-numeric-inputs-container">
            ${input}
            ${input2}
          </div>
        </div>`

    }

    /**
     * Round, source: https://stackoverflow.com/a/18358056
     *
     * @param {number} val
     * @param {number} [precision]
     * @return {number}
     */
    function round(val, precision = 0) {
      return +(`${Math.round(`${val}e+${precision}`)}e-${precision}`)
    }

    /**
     * Get width and font size for input, to help keep full value glanceable
     */
    function getInputStyle(inputValue, operator, precision) {
      let width = 37
      let fontSize = 13

      const roundedNumber = round(inputValue, precision)
      const stringValue = roundedNumber.toString()
      let numDigits = stringValue.length
      if (stringValue.includes('.')) {numDigits -= 0.75}

      if (
        numDigits > 4 &&
            (!['between', 'not between'].includes(operator) || numDigits <= 7)
      ) {
        fontSize = 12
        width += 6 * (numDigits - 4)
      } else if (numDigits > 7) {
        fontSize = 11
        width += 5.5 * (numDigits - 4)
      }

      const style = {
        width: `${width}px`,
        fontSize: `${fontSize}px`,
        numDigits // Not a standard style, but a helpful prop
      }

      return style
    }

    /** Make big input numbers fit on one more more often */
    function getResponsiveStyles(inputValue, inputValue2, operator, precision) {
      const inputStyle = getInputStyle(inputValue, operator, precision)
      const inputStyle2 = getInputStyle(inputValue2, operator, precision)
      const andStyle = { marginLeft: '4px' }
      const totalDigits = inputStyle.numDigits + inputStyle2.numDigits
      if (totalDigits > 14) {
        andStyle.marginLeft = '2px'
        andStyle.marginRight = '-2px'
        if (totalDigits > 16) {andStyle.fontSize = 11.5}
      }
      const styles = {
        input: inputStyle,
        input2: inputStyle2,
        and: andStyle
      }
      return styles
    }

    function getNumericFacetHtml(facet) {
      if (
        facet.filterNumbers.length === 0 ||
        facet.statistics.min === facet.statistics.max
      ) {
        return ''
      }

      const filterNumbers = facet.filterNumbers
      const statistics = facet.statistics

      const filtersHtml = getNumericQueryBuilder(facet, filterNumbers, statistics)

      const facetSel = `igv-facet-${facet.name}`
      const facetHtml = `
        <div class="igv-facet ${facetSel}" style="width: 250px; float: left;">
          <span class="igv-facet-header">${facet.name}</span>
          ${filtersHtml}
        </div>`

      return facetHtml
    }

    function getFacetsHtml(facetsContainer) {
      // console.log('facetsContainer', facetsContainer)
      const facetList = facetsContainer.facets.map(facetContainer => {
        let facetHtml
        if (facetContainer.type === 'categorical') {
          facetHtml = getCategoricalFacetHtml(facetContainer)
        } else {
          facetHtml = getNumericFacetHtml(facetContainer)
        }
        return facetHtml
      }).join('')

      const facetsHtml = `<div>${facetList}</div>`
      return facetsHtml
    }

  </script>
</head>

<body>

<h1>Ad-hoc filtering in IGV</h1>
<ul class="filters" style="float: left;">
</ul>


<div id="igvDiv" style="padding-top: 10px;padding-bottom: 10px; border:1px solid lightgray; clear: both;"></div>

<script type="module">

    import igv from "../js/index.js"

    const options =
        {
            // Example of fully specifying a reference .  We could alternatively use  "genome: 'hg19'"
            reference: {
                "id": "hg19",
                "name": "Human (CRCh37/hg19)",
                "fastaURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta",
                "indexURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta.fai",
                "cytobandURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/cytoBand.txt"
            },
            locus: "19:11,199,138-11,245,496",
            tracks:
                [
                    {
                        name: "Phase 3 WGS variants",
                        type: "variant",
                        format: "vcf",
                        visibilityWindow: 3000000,
                        url: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz",
                        indexURL: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz.tbi"
                    },
                    {
                        name: "Genes",
                        type: "annotation",
                        format: "bed",
                        url: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz",
                        indexURL: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz.tbi",
                        order: Number.MAX_VALUE,
                        visibilityWindow: 300000000,
                        displayMode: "EXPANDED"
                    }
                ]

        }

    var igvDiv = document.getElementById("igvDiv")

    window.igv = igv

    const browser = await igv.createBrowser(igvDiv, options)
    window.igvBrowser = browser

    browser.on('locuschange', referenceFrameList => {
      const trackSelector = 'Phase 3 WGS variants'
      const facetsContainer = initFacets(trackSelector, browser)
      const facetsHtml = getFacetsHtml(facetsContainer)

      const filterContainerDom = document.querySelector('.filters')
      filterContainerDom.innerHTML = ''
      filterContainerDom.insertAdjacentHTML('beforeend', facetsHtml)

      const {
        features, featuresByFacet, loadedFacets: facets,
        filterCounts
      } = initCrossfilter(facetsContainer)

      const filtersDom = document.querySelectorAll('.igv-filter')
      filtersDom.forEach(filterDom => {
        const selection = getSelection()
        console.log('filterDom', filterDom)
        filterDom.addEventListener('change', (event) => {
          console.log('in filterDom change')
          const facetName = filterDom.getAttribute('data-facet-name');
          filterFeaturesNew(selection, featuresByFacet, facets, features, facets)
          // filterFeatures(trackSelector, facetName)
        })
      })
    })

</script>

</body>

</html>
