<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link href=img/favicon.ico rel="shortcut icon">
    <title>Interactive filtering in igv.js</title>
    <style>
      .igv-facet .brush .selection {
          fill-opacity: .1;
          fill: #3d5a87;
          stroke: #3d5a87;
          shape-rendering: crispEdges;
      }

      .igv-filters-container {
        font-family: "Open Sans", sans-serif;
        font-size: 13px;
      }

      .igv-facet-header {
        font-weight: bold;
      }

      .igv-facet {
        margin-top: 10px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/crossfilter2@1.5.4"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/d3-selection@3.0.0/dist/d3-selection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-dispatch@3.0.1/dist/d3-dispatch.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-brush@3.0.0/dist/d3-brush.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-array@3.2.4/dist/d3-array.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3.0.1/dist/d3-interpolate.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale@4.0.2/dist/d3-scale.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.js"></script>
    <script>

    const HISTOGRAM_BAR_MAX_HEIGHT = 20
    const SLIDER_HANDLEBAR_WIDTH = 6
    const HANDLEBAR_Y = -1 * (HISTOGRAM_BAR_MAX_HEIGHT - 1)

    /** Render update to reflect newly-selected features in IGV track */
    function updateTrack(trackIndex, filteredFeatures, igv, igvBrowser) {
      igv.FeatureUtils.packFeatures(filteredFeatures)
      const range = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.range
      igvBrowser.trackViews[trackIndex].track.featureSource.featureCache =
        new igv.FeatureCache(filteredFeatures, igvBrowser.genome, range)

      igvBrowser.trackViews[trackIndex].track.clearCachedFeatures()
      igvBrowser.trackViews[trackIndex].track.updateViews()
    }

    /** Get unfiltered genomic features on current chromosome */
    function getOriginalChrFeatures(trackIndex, igvBrowser) {
      const chr = Array.from(igvBrowser.tracks[0].trackView.viewports[0].featureCache.features.keys())[0]

      if (
        typeof window.originalFeatures === 'undefined' ||
        chr in window.originalFeatures === false
      ) {
        window.originalFeatures = igvBrowser.trackViews[trackIndex].track.featureSource.featureCache.allFeatures
      }

      const originalChrFeatures = window.originalFeatures[chr]

      return originalChrFeatures
    }

    /** Determine if feature is in genomic frame */
    function getIsFeatureInFrame(feature, igvBrowser) {
      const frame = igvBrowser.referenceFrameList[0]

      const isFeatureInFrame = (
        // Contained:
        // Frame:     --------
        // Feature:     ----
        (feature.start >= frame.start && feature.end <= frame.end) ||

        // Overlaps start
        // Frame:     --------
        // Feature:  ----
        (feature.start <= frame.start && feature.end >= frame.start) ||

        // Overlaps end
        // Frame:     --------
        // Feature:         ----
        (feature.start <= frame.end && feature.end >= frame.end) ||

        // Spans
        // Frame:     --------
        // Feature: ------------
        (feature.start <= frame.start && feature.end >= frame.end)
      )

      return isFeatureInFrame
    }

    function getSelection() {

      const selection = {}

      const categoricalFilters = document.querySelectorAll('.igv-filter-categorical')
      categoricalFilters.forEach(input => {
        if (input.checked) {
          const facetName = input.getAttribute('data-igv-facet-name')
          const filter = input.value
          if (facetName in selection) {
            selection[facetName].push(filter)
          } else {
            selection[facetName] = [filter]
          }
        }
      })

      const numericFacets = document.querySelectorAll('.igv-facet-numeric-query-builder')
      numericFacets.forEach(facet => {
        const facetName = facet.getAttribute('data-igv-facet-name')
        const value = facet.querySelector('.igv-numeric-query-input-value').value
        const value2 = facet.querySelector('.igv-numeric-query-input-value2').value

        const operator = 'between'
        selection[facetName] = [[operator, [value, value2]]]
        // if (['between', 'not between'].includes(operator)) {
        //   numericFilters = [[operator, [value, value2]]]
        // } else {
        //   numericFilters = [[operator, value]]
        // }
      })

      return selection
    }

    /**
     * Determine if a feature satisfies any numeric filters
     *
     * @param {Number} d - A numeric datum; a numeric value for a feature
     * @param {Array<Array<String, *>>} numericFilters Filters for a numeric
     *   facet. Each filter has an operator and a value.  Values can be a number
     *   or an array of two numbers.
     *
     *   Example simple numeric filters:
     *   - ["=", 1.3]
     *   - ["!=", 1.3]
     *   - [">", 6]
     *   - [">=", 6]
     *   - ["<", 6]
     *   - ["<=", 6]
     *   - ["between", [5, 42]] -- inclusive, i.e. 5 <= d <= 42
     *   - ["not between", [5, 42]] -- inclusive, i.e. !(5 <= d <= 42)
     *
     *   Example compound numeric filters:
     *   - [["between", [95, 100]], ["between", [1200, 1300]] -- (95 <= d <= 100) or (1200 <= d <= 1300)
     *
     *   Compound numeric filters could be used to e.g.:
     *     - isolate the peaks of multimodal distributions (as in concrete example above)
     *     - isolate the tails of distributions
     *
     *   TODO:
     *   - Enable percentile filtering, i.e. beyond raw values.  Requires 1-time full sort, then trivial.
     *
     * @returns {Boolean} Whether feature datum passed any filters
     */
    function applyNumericFilters(d, rawFilters) {
      // const [numericFilters, includeNa] = rawFilters
      const numericFilters = rawFilters
      const includeNa = true

      if (includeNa && d === null) {return true}

      for (let i = 0; i < numericFilters.length; i++) {
        const [operator, value] = numericFilters[i]
        if (operator === '=') {
          // for fastest querying, exit function immediately upon _any_ condition
          // evaluating to true
          if (d === value) {return true}
        } else if (operator === '!=') {
          if (d !== value) {return true}
        } else if (operator === '>') {
          if (d > value) {return true}
        } else if (operator === '>=') {
          if (d >= value) {return true}
        } else if (operator === '<') {
          if (d < value) {return true}
        } else if (operator === '<=') {
          if (d <= value) {return true}
        } else if (operator === 'between') {
          if (value[0] <= d && d <= value[1]) {return true}
        } else if (operator === 'not between') {
          if (!(value[0] <= d && d <= value[1])) {return true}
        }
      }

      return false
    }

    function filterFeatures(trackSelector, filterResults, facets, igvBrowser) {
      const [filteredFeatures, filterCounts] = filterResults
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);
      const featuresInFrame = getFeaturesInFrame(trackSelector, igvBrowser)

      const featuresToPlot = []
      for (let i = 0; i < filteredFeatures.length; i++) {
        const rawIndex = filteredFeatures[i].rawIndex
        const featureToPlot = featuresInFrame[rawIndex]
        featuresToPlot.push(featureToPlot)
      }

      updateTrack(trackIndex, featuresToPlot, igv, igvBrowser)

      Object.entries(filterCounts).forEach(([facetName, countsByFilter], i) => {
        const facet = facets[i]
        Object.entries(countsByFilter).forEach(([filterName, count]) => {
          if (facet.type === 'categorical') {
            const filterSel =
              `.igv-filter-label[data-igv-facet-name="${facet.name}"][data-igv-filter-name="${filterName}"] ` +
              `.igv-filter-count`
            const countDom = document.querySelector(filterSel)
            countDom.textContent = count
          }
        })
      })
    }

    function getFeaturesInFrame(trackSelector, igvBrowser) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser);
      const originalChrFeatures = getOriginalChrFeatures(trackIndex, igvBrowser)
      const featuresInFrame = originalChrFeatures.filter(
        feature => getIsFeatureInFrame(feature, igvBrowser)
      )
      return featuresInFrame
    }

    /** Get index position of track in IGV browser, given its name or index */
    function getTrackIndex(trackSelector, igvBrowser) {
      let trackIndex = null
      if (typeof trackSelector === 'string') {
        igvBrowser.trackViews.find((trackView, i) => {
          trackIndex = i
          return trackView.track.config?.name === trackSelector
        })
      } else {
        trackIndex = trackSelector
      }
      return trackIndex
    }

    /** Get D3 scale to convert between numeric facet values and pixels */
    function getXScale(bars, histogramWidth, hasNull) {
      hasNull = false // TODO: Parameterize

      const barStartIndex = hasNull ? 2 : 0
      const valueDomain = []
      const pxRange = []
      for (let i = barStartIndex; i < bars.length; i++) {
        const bar = bars[i]
        valueDomain.push(bar.start)
        const x = bar.x + (hasNull ? 0 : SLIDER_HANDLEBAR_WIDTH + 2)
        pxRange.push(x)
      }
      const lastBar = bars.slice(-1)[0]
      valueDomain.push(lastBar.end)
      pxRange.push(histogramWidth + (hasNull ? 0 : SLIDER_HANDLEBAR_WIDTH))

      const xScale = d3.scaleLinear(valueDomain, pxRange)
      return xScale
    }

    /** Get width and height for SVG elements for histogram */
    function getHistogramSvgDimensions(bars) {
      const lastBar = bars.slice(-1)[0]
      const histogramWidth = lastBar.x + lastBar.width
      const histogramHeight = HISTOGRAM_BAR_MAX_HEIGHT + 2
      return [histogramWidth, histogramHeight]
    }

    /** Get container offsets for brush */
    function getSliderStyle(bars, histogramWidth) {
      const barWidth = bars[0].width
      const hasNull = bars[0].isNull

      const sliderLeft = hasNull ? 0 : -1 * (SLIDER_HANDLEBAR_WIDTH + 1)
      const sliderWidth = histogramWidth + (hasNull ? barWidth : 2 * SLIDER_HANDLEBAR_WIDTH + 2)

      const extentStartX = hasNull ? 2 * barWidth + 2 : SLIDER_HANDLEBAR_WIDTH + 2
      const extentWidth = hasNull ? histogramWidth : histogramWidth + SLIDER_HANDLEBAR_WIDTH

      return [sliderLeft, sliderWidth, extentStartX, extentWidth]
    }

    /** Return new values from D3 brush selection */
    function parseValuesFromBrushSelection(brushSelection, xScale, precision) {
      const extent = brushSelection.map(xScale.invert)
      const newValue1 = round(extent[0], precision)
      const newValue2 = round(extent[1], precision)
      return [newValue1, newValue2]
    }

  /** Handle slider move event (i.e., drag or resize) */
  function handleBrushMove(event, xScale, facet) {
    const brushSelection = event.selection
    if (!brushSelection) {return}

    const precision = getPrecision(facet)

    const [newValue, newValue2] =
      parseValuesFromBrushSelection(brushSelection, xScale, precision)

    const max = facet.statistics.max
    const min = facet.statistics.min

    if (
      newValue > max || newValue < min || newValue2 > max || newValue2 < min ||
      Number.isNaN(newValue) || Number.isNaN(newValue2)
    ) {
      // Prevent handlebar misdisplay if crosshair-select moves out-of-bounds
      return
    }

    const facetSel = getFacetSelector(facet)
    const [input, input2] = Array.from(document.querySelectorAll(`.${facetSel} input`))

    input.value = newValue
    input2.value = newValue2

    const [handlebar, handlebar2] = Array.from(document.querySelectorAll(`.${facetSel} .handlebar`))

    const newTranslate = getHandlebarTranslate(brushSelection[0])
    const newTranslate2 = getHandlebarTranslate(brushSelection[1])

    handlebar.setAttribute('transform', newTranslate)
    handlebar2.setAttribute('transform', newTranslate2)
  }

  /** Handle slider move event (i.e., drag or resize) */
  function handleBrushEnd(event, facet) {
    const brushSelection = event.selection
    if (!brushSelection) {return}

    const facetSel = getFacetSelector(facet)
    const input = document.querySelector(`.${facetSel} input`)
    if (!input) return

    const changeEvent = new Event('change')
    input.dispatchEvent(changeEvent)
  }


  function getHandlebarTranslate(x) {
    return `translate(${x}, ${HANDLEBAR_Y})`
  }

    function getHistogramSlider(
      facet, bars, histogramWidth, histogramHeight, brushSelection, xScale
    ) {
      // return ['', null]

      const sliderId = `igv-numeric-filter-histogram-slider___${facet.name}`
      const [sliderLeft, sliderWidth, extentStartX, extentWidth] = getSliderStyle(bars, histogramWidth)

      const defaultSelection = [
        [brushSelection[0], 0],
        [brushSelection[1], histogramHeight]
      ]

      const brush = d3.brushX()
        .extent([
          [extentStartX, 0],
          [extentWidth, histogramHeight]
        ])
        .on('brush', (event) => handleBrushMove(event, xScale, facet))
        .on('end', (event) => handleBrushEnd(event, facet));

      const brushConf = [xScale, brush]

      const histogramSliderHtml =
        `<div>
          <svg
            height=${histogramHeight}
            width=${sliderWidth}
            style="position: absolute; top: 0; left: ${sliderLeft}px"
            class="igv-numeric-filter-histogram-slider"
            id=${sliderId}
          >
            <path
              class="handlebar"
              fill="#EEE"
              opacity="0.8"
              stroke="#000"
              stroke-width="0.5"
              cursor="ew-resize"
              d="${getHandlebarPath({ type: 'w' })}"
              transform="${getHandlebarTranslate(brushSelection[0])}"
            />
            <path
              class="handlebar"
              fill="#EEE"
              opacity="0.8"
              stroke="#000"
              stroke-width="0.5"
              cursor="ew-resize"
              d="${getHandlebarPath({ type: 'e' })}"
              transform="${getHandlebarTranslate(brushSelection[1])}"
            />
            <g
              class="brush igv-facet-slider"
              data-igv-facet-name="${facet.name}"
            >
            </g>
          </svg>
        </div>`

      return [histogramSliderHtml, brushConf]
    }

    /** Histogram for distribution of numeric facet values, with tooltips or slider */
    function getHistogram(
      facet, bars, histogramWidth, histogramHeight, operator,
      brushSelection, xScale, handleBrushMove, handleBrushEnd
    ) {
      const sliderId = `numeric-filter-histogram-slider___${facet.name}`
      // const [sliderLeft, sliderWidth, extentStartX, extentWidth] = getSliderStyle(bars, histogramWidth)

      const [sliderHtml, brushConf] = getHistogramSlider(
        facet, bars, histogramWidth, histogramHeight, brushSelection, xScale
      )

      const histogramHtml = `
        <div style="position: relative;">
          <svg
            height=${histogramHeight}
            width=${histogramWidth}
            style="border-bottom: 1px solid #AAA;"
            class="numeric-filter-histogram"
          >
            ${bars.map((bar, i) => {
              return (`
                <rect
                  fill=${bar.color}
                  x=${bar.x}
                  y=${bar.y}
                  width=${bar.width}
                  height=${bar.height}
                />`
              )
            }).join('')}
            ${sliderHtml}
          </svg>
        </div>`

      return [histogramHtml, brushConf]
    }

    function getQuantiles(sortedNumbers, max, min, numBins=15) {
      const size = (max - min) / numBins
      const quantiles = new Array(numBins).fill(0)

      for (let i = 1; i < numBins + 1; i++) {
        const prevBinNum = min + (i - 1) * size
        const binNum = min + i * size
        for (let j = 0; j < sortedNumbers.length; j++) {
          const num = sortedNumbers[j]
          if (prevBinNum < num && num <= binNum) {
            quantiles[i - 1] += 1
          }
        }
      }

      return quantiles
    }

    function getStatistics(numbers) {
      // Sort the array in ascending order
      numbers.sort((a, b) => a - b);

      // Compute the sum using a loop for faster mean calculation
      let sum = 0;
      for (let i = 0; i < numbers.length; i++) {
          sum += numbers[i];
      }
      const mean = sum / numbers.length;

      const max = numbers[numbers.length - 1];
      const min = numbers[0];
      const median = getMedian(numbers);

      // Divide the array into two halves
      const midIndex = Math.floor(numbers.length / 2);
      const lowerHalf = numbers.slice(0, midIndex);
      const upperHalf = numbers.length % 2 === 0
          ? numbers.slice(midIndex)
          : numbers.slice(midIndex + 1);

      const q1 = getMedian(lowerHalf);
      const q3 = getMedian(upperHalf);

      const quantiles = getQuantiles(numbers, max, min)

      return { min, q1, median, q3, max, mean, quantiles };
    }

    /**
 * Get SVG for handlebar UI, as an affordance for resizing
 *
 * Inspired by https://crossfilter.github.io/crossfilter
 */
function getHandlebarPath(d) {
  const sweepFlag = d.type === 'e' ? 1 : 0
  const x = sweepFlag ? 1 : -1
  const y = HISTOGRAM_BAR_MAX_HEIGHT
  const width = SLIDER_HANDLEBAR_WIDTH

  // Construct an SVG arc
  // Docs: https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs
  const start = `M${ .5 * x },${ y}`
  const rx = width
  const ry = width
  const xAxisRotation = 0
  const largeArcFlag = 0
  const arc1X = ((width + 0.5) * x)
  const arc1Y = y + 6
  const arc1EndLine = `V${ 2 * y - width}`
  const arc2X = 0.5 * x
  const arc2Y = 2 * y
  const arc1 = `A${rx},${ry} ${xAxisRotation} ${largeArcFlag} ${sweepFlag} ${arc1X},${arc1Y}`
  const arc2 = `A${rx},${ry} ${xAxisRotation} ${largeArcFlag} ${sweepFlag} ${arc2X},${arc2Y}`

  /* eslint-disable */
  // Each handlebar has two vertical lines in it, resembling notched grooves
  const notches = (
    "M" + (2.5 * x) + "," + (y + (width + 2)) +
    "V" + (2 * y - (width + 2)) +
    "M" + (4.5 * x) + "," + (y + (width + 2)) +
    "V" + (2 * y - (width + 2))
  )
  /* eslint-enable */

  /* eslint-disable */
  return (
    start +
    arc1 +
    arc1EndLine +
    arc2 +
    "Z" +
    notches
  )
  /* eslint-enable */
}

    /** Get display attributes for histogram bars */
    function getHistogramBarDisplayAttrs(bars, maxCount) {
      const barRectAttrs = []
      const maxHeight = HISTOGRAM_BAR_MAX_HEIGHT
      bars.forEach((bar, i) => {
        const height = maxHeight * (bar.count / maxCount)
        const width = 11
        const attrs = Object.assign({
          x: (width + 1) * i,
          y: maxHeight - height + 1,
          width,
          height,
          // color: (bar.isNull) ? '#888' : '#3D5A87'
          color: '#3D5A87',
          isNull: false // TODO: Move this upstream
        }, bar)
        barRectAttrs.push(attrs)
      })
      return barRectAttrs
    }


    /** Get histogram to show with numeric filter */
    function getHistogramBars(facet) {
      const hasNull = false; // TODO: move up

      let bars = facet.statistics.quantiles

      let maxCount = 0
      for (let i = 0; i < bars.length; i++) {
        const count = bars[i]
        if (count > maxCount) {maxCount = count}
      }

      const maxValue = facet.statistics.max
      const minValue = facet.statistics.min
      const numBins = bars.length
      const numBinsNullTrimmed = hasNull ? numBins - 2 : numBins
      const binSize = (maxValue - minValue) / numBinsNullTrimmed

      for (let i = 0; i < numBins; i++) {
        const isNull = hasNull && i < 2
        let start
        let end
        const indexNullTrimmed = hasNull ? i - 2 : i
        if (isNull) {
          start = null
          end = null
        } else {
          start = minValue + (binSize * indexNullTrimmed)
          end = minValue + (binSize * (indexNullTrimmed + 1))
        }
        bars[i] = {
          count: bars[i],
          start,
          end
        }
      }

      bars = getHistogramBarDisplayAttrs(bars, maxCount)

      return bars
    }

    function getMedian(numbers) {
      const midIndex = Math.floor(numbers.length / 2);

      // If the array has an odd length, return the middle number
      if (numbers.length % 2 !== 0) {
        return numbers[midIndex];
      }

      // If the array has an even length, return the average of the two middle numbers
      return (numbers[midIndex - 1] + numbers[midIndex]) / 2;
    }

    /** Get crossfilter-initialized features by facet */
    function getFeaturesByFacet(features, facetNames) {
      const featureCrossfilter = crossfilter(features)
      window.featureCrossfilter = featureCrossfilter
      const featuresByFacet = {}
      for (let i = 0; i < facetNames.length; i++) {
        const facetName = facetNames[i]
        const facetCrossfilter = featureCrossfilter.dimension(d => d.facetIndex[i])
        featuresByFacet[facetName] = facetCrossfilter
      }
      return featuresByFacet
    }

    /** Get filtered feature results, and counts */
    function getFilteredFeatures(
      selection, featuresByFacet, facets, filterableFeatures
    ) {
      const t0 = Date.now()

      let fn; let facet; let results

      if (Object.keys(selection).length === 0) {
        results = filterableFeatures
      } else {
        for (let i = 0; i < facets.length; i++) {
          facet = facets[i]
          const facetName = facet.name
          if (facetName in selection) {
            if (facet.type === 'categorical') {
              // e.g. 'infant_sick_YN'
              const friendlyFilters = selection[facetName] // e.g. ['yes', 'NA']

              const filter = new Set()
              friendlyFilters.forEach(friendlyFilter => {
                const filterIndex = facet.filterNames.indexOf(friendlyFilter)
                filter.add(filterIndex)
              })

              fn = function(d, i) {
                return filter.has(d)
              }

              // Apply the actual crossfilter method
              featuresByFacet[facetName].filterFunction(fn)
            } else {
              const numericFilters = selection[facetName] // e.g. [0, 20]

              fn = function(d) {
                // return true
                return applyNumericFilters(d, numericFilters)
              }
              featuresByFacet[facetName].filterFunction(fn)
            }
          } else {
            fn = null
            // Apply the actual crossfilter method
            featuresByFacet[facetName].filter(fn)
          }
        }
        results = featuresByFacet[facet.name].top(Infinity)
      }

      const facetNames = facets.map(facet => facet.name)
      const t0Counts = Date.now()
      const counts = getFilterCounts(facetNames, featuresByFacet, facets, selection)

      return [results, counts]
    }

    /** Get counts for each filter, in each facet */
    function getFilterCounts(facetNames, featuresByFacet, facets, selection) {
      const filterCounts = {}

      for (let i = 0; i < facets.length; i++) {
        const facet = facets[i]
        const facetName = facet.name
        const facetCrossfilter = featuresByFacet[facetName]
        // Set counts for each filter in facet
        const rawFilterCounts = facetCrossfilter.group().top(Infinity)
        let countsByFilter

        if (facet.type === 'categorical') {
          countsByFilter = {}
          facet.filterNames.forEach((filterName, j) => {
            let count = null
            // check for originalGroups array first, if present
            const originalFilterNames = facets[i].originalFilterNames || facets[i].filterNames
            const filterNameIdx = originalFilterNames.indexOf(filterName)
            const rawFilterKeyAndValue = rawFilterCounts.find(rfc => rfc.key === filterNameIdx)
            if (rawFilterKeyAndValue) {
              count = rawFilterKeyAndValue.value
            }
            countsByFilter[filterName] = count
          })
        } else {
          countsByFilter = []
          for (let j = 0; j < rawFilterCounts.length; j++) {
            // For numeric facets, `rawFilterCounts` is an array of objects, where
            // each object is a distinct numeric value observed in the facet;
            // the `key` of this object is the numeric value, and the `value` is
            // how many features were observed with that numeric value.
            const countObject = rawFilterCounts[j]
            const filterValueAndCount = [countObject.key, countObject.value]
            countsByFilter.push(filterValueAndCount)
          }

          // Sort array by numeric value, to aid later histogram, etc.
          countsByFilter = countsByFilter.sort((a, b) => a[0] - b[0])
        }
        filterCounts[facet.name] = countsByFilter
      }

      // If a filter has been deselected, set its count to 0
      if (selection) {
        Object.entries(filterCounts).forEach(([facetName, countsByFilter]) => {
          Object.entries(countsByFilter).forEach(([filterName, count]) => {
            let newCount = count
            if (!(facetName in selection && selection[facetName]?.includes(filterName))) {
              newCount = 0
            }
            filterCounts[facetName][filterName] = newCount
          })
        })
      }

      return filterCounts
    }

    function initCrossfilter(facetsContainer) {
      const facets = facetsContainer.facets
      const rawFeatures = facetsContainer.features
      const facetNames = facets.map(facet => facet.name)
      const features = []

      for (let i = 0; i < rawFeatures.length; i++) {
        const feature = { 'rawIndex': i }

        // For categorical facets, we have an array of integers, e.g. [6, 0, 7, 0, 0].
        // Each element in the array is the index-offset of the feature's category assignment
        // for the facet at that index.
        const facetIndex = rawFeatures[i]
        feature.facetIndex = facetIndex
        features.push(feature)
      }

      const featuresByFacet = getFeaturesByFacet(features, facetNames)

      const filterCounts = {} // getFilterCounts(facetNames, featuresByFacet, facets, null)

      return {
        features, featuresByFacet, facets,
        filterCounts
      }
    }

    /**
     * Initialize facets and filters for the current genomic frame
     *
     * Output:
     * {
     *   "features": [
     *      // Each "feature" (e.g. variant, read, gene) is represented as an
     *      // array of numbers.  For categorical facets, each number is a
     *      // compact representation (e.g. 0) of the filter / value (e.g.
     *      // "SNP") of a particular facet / dimension (e.g. "VT").
     *      [<Number>]
     *    ],
     *   "facets": [
     *     {
     *       "name": <String>, // Internal name of facet, e.g. "VT"
     *
     *       "displayName": <String>, // e.g. "Variant type" TODO
     *
     *       "type": <String> // "categorical" or "integer" or "float"
     *
     *       // For categorical: names of filters in facet
     *       // The index of these names correspond to the integer value at the
     *       // appropriate position in the `features` array.
     *       "filterNames": [<String>],
     *
     *       // For categorical: number of features satisfying each filter
     *       "countsByFilterName": {
     *          <String>: <Integer>
     *       }
     *
     *      // For integer or float: numeric values observed for this facet
     *      "filterNumbers": [<Number>],
     *
     *      "statistics": {
     *        "min": <Number>,
     *        "q1": <Number>,
     *        "median": <Number>,
     *        "q3": <Number>,
     *        "max": <Number>
     *      }
     *     }
     *   ]
     * }
     */
    function initFacets(trackSelector, igvBrowser) {
      const trackIndex = getTrackIndex(trackSelector, igvBrowser)
      const featuresInFrame = getFeaturesInFrame(trackIndex, igvBrowser)

      // Populate facets model, except for filterNames array values
      let facets = []
      const headInfo = featuresInFrame[0].header.INFO
      const dimensions = Object.keys(headInfo);
      dimensions.forEach(dimension => {
        const igvFacet = headInfo[dimension]
        // string, flag, integer, or float
        const igvType = igvFacet.Type.toLowerCase()
        const type = ['string', 'flag'].includes(igvType) ? 'categorical' : igvType
        const description = igvFacet.Description
        const facet = {'name': dimension, type, description}
        if (type === 'categorical') {
          facet.filterNames = []
          facet.countsByFilterName = {}
        } else {
          facet.filterNumbers = []
          facet.statistics = {}
        }
        facets.push(facet)
      })

      // Populate features, and (for each facet) filterNames
      let features = []
      for (let i = 0; i < featuresInFrame.length; i++) {
        const feature = []
        const igvFeature = featuresInFrame[i]
        const info = igvFeature.info
        let j = 0
        for (facetName in headInfo) {
          let value
          if (facetName in info === false) {
            // Use an "empty" value if the feature lacks a value
            // for this dimension, which is pretty common.
            value = undefined
          } else {
            const rawValue = info[facetName]
            const facet = facets[j]
            if (facet.type === 'categorical') {
              if (!facet.filterNames.includes(rawValue)) {
                // Populate filterNames
                facet.filterNames.push(rawValue);
                facet.countsByFilterName[rawValue] = 0
              }

              // Using index offsets as values, rather than raw strings, helps
              // make categorical filtering fast.
              value = facet.filterNames.indexOf(rawValue)
              facet.countsByFilterName[rawValue] += 1
            } else {
              const isFloat = facet.type === 'float'
              value = isFloat ? parseFloat(rawValue) : parseInt(rawValue)
              facet.filterNumbers.push(value)
            }
            facets[j] = facet
          }
          feature.push(value)
          j++
        }

        // Populate features
        features.push(feature)
      }

      const undefinedIndexes = new Set()

      const untrimmedFacets = facets
      // Trim unused facets
      facets = facets.filter((facet, i) => {
        if (
          (facet.type === 'categorical' && facet.filterNames.length < 2) ||
          (facet.type !== 'categorical' && facet.filterNumbers.length < 2)
        ) {
          undefinedIndexes.add(i)
          return false
        } else {
          return true
        }
      })

      const untrimmedToTrimmedFacetIndexMap = {}
      untrimmedFacets.forEach((untrimmedFacet, i) => {
        facets.forEach((facet, j) => {
          if (untrimmedFacet.name === facet.name) {
            untrimmedToTrimmedFacetIndexMap[i] = j
          }
        })
      })

      // Trim undefined indexes from features
      if (undefinedIndexes.size > 0) {
        const trimmedFeatures = []
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          const trimmedFeature = []
          for (let j = 0; j < feature.length; j++) {
            if (!undefinedIndexes.has(j)) { // If this facet isn't totally empty
              let featureValue = feature[j]

              // Handle facets where _some but not all_ values are not available
              if (featureValue === undefined) {
                featureValue = null
                const k = untrimmedToTrimmedFacetIndexMap[j]
                if (facets[k].type === 'categorical') {
                  if (!facets[k].filterNames.includes(null)) {
                    facets[k].filterNames.push(null)
                    facets[k].countsByFilterName[null] = 1
                  } else {
                    facets[k].countsByFilterName[null] += 1
                  }
                }
              }
              trimmedFeature.push(featureValue)
            }
          }
          trimmedFeatures.push(trimmedFeature)
        }
        features = trimmedFeatures
      }

      // Populate statistics for numeric facets
      facets = facets.map(facet => {
        if (facet.type === 'categorical') return facet

        const {min, q1, median, q3, max, mean, quantiles} =
          getStatistics(facet.filterNumbers)
        facet.statistics = {min, q1, median, q3, max, mean, quantiles}

        return facet
      })

      const facetOrder = [
        'VT',
        'AF','AFR_AF', 'AMR_AF', 'EAS_AF', 'EUR_AF', 'SAS_AF',
        'DP',
        'AA',
        'AC'
      ]
      facets = facets.sort((a, b) => {
        const indexA = facetOrder.indexOf(a.name)
        const indexB = facetOrder.indexOf(b.name)
        return indexA - indexB
      })

      return {facets, features}
    }


    function togglePartialCollapse(event) {
        const target = event.target
        const attrName = 'data-igv-is-partly-collapsed'
        const oldIsPartlyCollapsed = target.getAttribute(attrName) === 'true'
        const newIsPartlyCollapsed = !oldIsPartlyCollapsed
        const facetName = target.getAttribute('data-igv-facet-name')

        const filterSel = `.igv-filter[data-igv-facet-name="${facetName}"]`
        document.querySelectorAll(filterSel).forEach((checkbox, i) => {
          const filterDom = checkbox.parentElement.parentElement
          if (newIsPartlyCollapsed && i >= 5) {
            // TODO: Consider optimizing by batching DOM writes
            filterDom.style = 'display: none;'
          } else {
            filterDom.style = ''
          }
        })

        document.querySelector('.igv-facet-toggle').setAttribute(attrName, newIsPartlyCollapsed)
      }

    function getFacetSelector(facet) {
      return `igv-facet-${facet.name}`
    }

    function getFriendlyFacetName(facet) {
      const friendlyNames = {
        'VT': 'Variant type',
        'AA': 'Ancestral allele',
        'AC': 'Allele count',
        'AF': 'Allele frequency',
        'AFR_AF': 'AF: African',
        'AMR_AF': 'AF: Admixed American',
        'EAS_AF': 'AF: East Asian',
        'EUR_AF': 'AF: European',
        'SAS_AF': 'AF: South Asian',
        'DP': 'Read depth'
      }

      let friendlyName = facet.name
      if (facet.name in friendlyNames) {
        friendlyName = `${friendlyNames[facet.name]}`
      }

      return friendlyName
    }

    /**
     * Get checkboxes with filter name and count for categorical feature metadata
     */
    function getCategoricalFacetHtml(facet, isPartlyCollapsed=true) {
      // Categorical facets need > 1 filter to be useful
      const numFilters = facet.filterNames.length
      if (numFilters < 2) return ''

      let filters = facet.filterNames;

      // Get list of filter checkboxes
      const filtersHtml = filters.map((filterName, i) => {
        let style = ''
        if (isPartlyCollapsed && i >= 5) style = 'display: none;'

        const facetFilterAttrs = `
          data-igv-facet-name="${facet.name}"
          data-igv-filter-name="${filterName}"`

        const fullName = `${facet.name}:${filterName}`
        const attrs = `
          value="${filterName}"
          name="${fullName}"
          class="igv-filter igv-filter-categorical"
          ${facetFilterAttrs}`

        const count = facet.countsByFilterName[filterName]
        const filterHtml = `
          <label class="igv-filter-label" style="${style}" ${facetFilterAttrs}>
            <div>
              <input type="checkbox" ${attrs} checked />
              <span class="igv-filter-label-text">${filterName}</span>
              <span class="igv-filter-label-quantities">
                <span class="igv-filter-count">${count}</span>
              </span>
            </div>
          </label>`
        return filterHtml
      }).join('')

      let moreOrLess = ''
      if (numFilters > 5) {
        moreOrLess = `
          <a
            class="igv-facet-toggle"
            data-igv-facet-name="${facet.name}"
            data-igv-is-partly-collapsed="${isPartlyCollapsed}"
            onClick="togglePartialCollapse(event)"
          >
            ${isPartlyCollapsed ? 'More...' : 'Less...'}
          </a>`
        }

      const friendlyName = getFriendlyFacetName(facet)

      const facetSel = getFacetSelector(facet)
      // Add a facet header to the filters
      const facetHtml = `
        <div class="igv-facet ${facetSel}" style="width: 250px;">
          <span class="igv-facet-header">${friendlyName}</span>
          ${filtersHtml}
          ${moreOrLess}
        </div>`

      return facetHtml
    }

    function getNumericQueryInput(value, facet, filterName, style) {
      return `
        <input
          type="text"
          class="igv-filter igv-numeric-query-input igv-numeric-query-input-${filterName}"
          data-igv-facet-name="${facet.name}"
          name="${facet.name}:${filterName}"
          value="${value}"
          style="width: ${style.width}; font-size: ${style.fontSize};"
        />`
    }

    function getPrecision(numericFacet) {
      return numericFacet.type === 'integer' ? 0 : 2
    }

    function getNumericQueryBuilder(facet, filterNumbers, statistics) {
      const inputValue = statistics.min
      const inputValue2 = statistics.max
      const operator = 'and'
      const precision = getPrecision(facet)
      const styles = getResponsiveStyles(inputValue, inputValue2, operator, precision)

      const hasNull = false // TODO: Move upstream

      const histogramWidth = 150

      const bars = getHistogramBars(facet)

      // Enables converting numeric facet values to pixels, and vice versa
      const xScale = getXScale(bars, histogramWidth, hasNull)
      const brushSelection = [inputValue, inputValue2].map(xScale)

      const [histogram, brushConf] = getHistogram(
        facet, bars, histogramWidth, 20, 'between', brushSelection, xScale
      )

      const input = getNumericQueryInput(statistics.min, facet, 'value', styles.input)
      const input2 = getNumericQueryInput(statistics.max, facet, 'value2', styles.input2)

      const numericQueryBuilderHtml = `
        <div
          class="igv-facet-numeric-query-builder"
          data-igv-facet-name="${facet.name}"
        >
          ${histogram}
          <div class="igv-facet-numeric-inputs-container">
            ${input}
            ${input2}
          </div>
        </div>`

      return [numericQueryBuilderHtml, brushConf]

    }

    /**
     * Round, source: https://stackoverflow.com/a/18358056
     *
     * @param {number} val
     * @param {number} [precision]
     * @return {number}
     */
    function round(val, precision = 0) {
      return +(`${Math.round(`${val}e+${precision}`)}e-${precision}`)
    }

    /**
     * Get width and font size for input, to help keep full value glanceable
     */
    function getInputStyle(inputValue, operator, precision) {
      let width = 37
      let fontSize = 13

      const roundedNumber = round(inputValue, precision)
      const stringValue = roundedNumber.toString()
      let numDigits = stringValue.length
      if (stringValue.includes('.')) {numDigits -= 0.75}

      if (
        numDigits > 4 &&
            (!['between', 'not between'].includes(operator) || numDigits <= 7)
      ) {
        fontSize = 12
        width += 6 * (numDigits - 4)
      } else if (numDigits > 7) {
        fontSize = 11
        width += 5.5 * (numDigits - 4)
      }

      const style = {
        width: `${width}px`,
        fontSize: `${fontSize}px`,
        numDigits // Not a standard style, but a helpful prop
      }

      return style
    }

    /** Make big input numbers fit on one more more often */
    function getResponsiveStyles(inputValue, inputValue2, operator, precision) {
      const inputStyle = getInputStyle(inputValue, operator, precision)
      const inputStyle2 = getInputStyle(inputValue2, operator, precision)
      const andStyle = { marginLeft: '4px' }
      const totalDigits = inputStyle.numDigits + inputStyle2.numDigits
      if (totalDigits > 14) {
        andStyle.marginLeft = '2px'
        andStyle.marginRight = '-2px'
        if (totalDigits > 16) {andStyle.fontSize = 11.5}
      }
      const styles = {
        input: inputStyle,
        input2: inputStyle2,
        and: andStyle
      }
      return styles
    }

    function getNumericFacetHtml(facet) {
      if (
        facet.filterNumbers.length === 0 ||
        facet.statistics.min === facet.statistics.max
      ) {
        return ''
      }

      const filterNumbers = facet.filterNumbers
      const statistics = facet.statistics

      const [filtersHtml, brushConf] = getNumericQueryBuilder(facet, filterNumbers, statistics)

      const friendlyName = getFriendlyFacetName(facet)

      const facetSel = `igv-facet-${facet.name}`
      const facetHtml = `
        <div class="igv-facet ${facetSel}" style="width: 250px;">
          <span class="igv-facet-header">${friendlyName}</span>
          ${filtersHtml}
        </div>`

      return [facetHtml, brushConf]
    }

    function getFacetsHtml(facetsContainer) {

      const brushesByNumericFacetName = {}

      const facetList = facetsContainer.facets.map(facet => {
        let facetHtml
        if (facet.type === 'categorical') {
          facetHtml = getCategoricalFacetHtml(facet)
        } else {
          [facetHtml, brushConf] = getNumericFacetHtml(facet)
          if (brushConf) {
            brushesByNumericFacetName[facet.name] = brushConf
          }
        }
        return facetHtml
      }).join('')

      const facetsHtml = `<div>${facetList}</div>`
      return [facetsHtml, brushesByNumericFacetName]
    }

    function writeNumericFacetSliderBrushes(facets, brushesByNumericFacetName) {
      facets.forEach(facet => {
        if (facet.name in brushesByNumericFacetName) {
          const [xScale, brush] = brushesByNumericFacetName[facet.name]
          const selector = `.igv-facet-slider[data-igv-facet-name="${facet.name}"]`
          const brushDom = document.querySelector(selector)
          const min = facet.statistics.min
          const max = facet.statistics.max
          d3.select(selector)
            .call(brush)
            .call(brush.move, [min, max].map(xScale))
        }
      })
    }

    /** Helper to move brush when input values change (by user, not programmatic trigger) */
    function updateBrushSelection(facet, brushesByNumericFacetName, facetSelections) {
      const facetName = facet.name
      const [xScale, brush] = brushesByNumericFacetName[facetName]
      const selector = `.igv-facet-slider[data-igv-facet-name="${facetName}"]`
      const rawBrushSelection = facetSelections[facetName][0][1]
      const parseNumber = facet.type === 'integer' ? parseInteger : parseFloat
      const brushSelection = rawBrushSelection.map(n => parseNumber(n))
      d3.select(selector)
        .call(brush.move, brushSelection.map(xScale))
    }

    /**
     * Initialize interactive filtering in IGV, for the given track
     *
     * This sets up crossfilters, and writes facet range inputs or checkboxes.
    */
    function initIgvFacets(trackSelector, browser) {
      const facetsContainer = initFacets(trackSelector, browser)
      const [facetsHtml, brushesByNumericFacetName] = getFacetsHtml(facetsContainer)

      const filterContainerDom = document.querySelector('.igv-filters-container')
      filterContainerDom.innerHTML = ''
      filterContainerDom.insertAdjacentHTML('beforeend', facetsHtml)

      const {
        features, featuresByFacet, facets,
        filterCounts
      } = initCrossfilter(facetsContainer)

      window.facets = facets

      window.features = features
      window.featuresByFacet = featuresByFacet

      writeNumericFacetSliderBrushes(facets, brushesByNumericFacetName)

      const filtersDom = document.querySelectorAll('.igv-filter')
      filtersDom.forEach(filterDom => {
        filterDom.addEventListener('change', (event) => {
          const selection = getSelection()
          const facetName = filterDom.getAttribute('data-igv-facet-name')

          const facet = facets.find(facet => facet.name === facetName)

          if (event.isTrusted && facetName in brushesByNumericFacetName) {
            updateBrushSelection(facet, brushesByNumericFacetName, selection)
          }

          const filterResults =
            getFilteredFeatures(selection, featuresByFacet, facets, features)

          filterFeatures(trackSelector, filterResults, facets, igvBrowser)
        })
      })
    }

  </script>
</head>

<body>

<h1>Interactive filtering in IGV</h1>
<ul class="igv-filters-container" style="float: left;">
</ul>


<div id="igvDiv"></div>

<script type="module">

    import igv from "../js/index.js"

    const options =
        {
            // Example of fully specifying a reference .  We could alternatively use  "genome: 'hg19'"
            reference: {
                "id": "hg19",
                "name": "Human (CRCh37/hg19)",
                "fastaURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta",
                "indexURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/hg19.fasta.fai",
                "cytobandURL": "https://s3.amazonaws.com/igv.broadinstitute.org/genomes/seq/hg19/cytoBand.txt"
            },
            locus: "19:11,199,138-11,245,496",
            tracks:
                [
                    {
                        name: "Phase 3 WGS variants",
                        type: "variant",
                        format: "vcf",
                        visibilityWindow: 3000000,
                        url: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz",
                        indexURL: "https://s3.amazonaws.com/1000genomes/release/20130502/ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz.tbi"
                    },
                    {
                        name: "Genes",
                        type: "annotation",
                        format: "bed",
                        url: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz",
                        indexURL: "https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz.tbi",
                        order: Number.MAX_VALUE,
                        visibilityWindow: 300000000,
                        displayMode: "EXPANDED"
                    }
                ]

        }

    var igvDiv = document.getElementById("igvDiv")

    window.igv = igv

    const browser = await igv.createBrowser(igvDiv, options)
    window.igvBrowser = browser

    // This can be a track name (like here) or track positional index (e.g. 3)
    const trackToFilter = 'Phase 3 WGS variants'

    function handleFirstFeaturesLoaded(track) {
      initIgvFacets(trackToFilter, browser)

      // Remove event listener, so this only fires when the track is
      // initialized.  Without removal, this handler fires every time features
      // are updated; it would infinitely loop.
      browser.off('featuresloaded', handleFirstFeaturesLoaded)
    }
    browser.on('featuresloaded', handleFirstFeaturesLoaded)

    browser.on('locuschange', () => {
      initIgvFacets(trackToFilter, browser)
    })

</script>

</body>

</html>
